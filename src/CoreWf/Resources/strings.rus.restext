AbortingDueToDynamicUpdateFailure=WorkflowApplication было прервано из-за сбоя попытки обновления экземпляра.
AbortingDueToInstanceTimeout=Работа экземпляра рабочего процесса прервана, так как время его выполнения истекло.
AbortingDueToLoadFailure=Работа WorkflowApplication прервана, поскольку операция Load или LoadRunnableInstance вызвала исключение. Создайте новый объект WorkflowApplication, чтобы загрузить другой экземпляр рабочего процесса.
AbortingDueToVersionMismatch=Работа WorkflowApplication прервана, поскольку операция Load или LoadRunnableInstance вызвала исключение VersionMismatchException.
AbortInstanceOnTransactionFailureDoesNotMatch=Значение свойства AbortInstanceOnTransactionFailure действия TransactionScope "{0}", вложенного в действие TransactedReceiveScope "{1}", не должно быть равным false.
ActionItemCallbackInvoked=Вызван обратный вызов планировщика потока ввода-вывода.
ActionItemIsAlreadyScheduled=Элементу ActionItem уже было назначено время для выполнения, которое еще не было завершено.
ActionItemScheduled=Вызван обратный вызов планировщика потока ввода-вывода.
ActivityBlockingUpdate=Действие "{0}": {1}
ActivityCannotBeReferenced=Действие "{1}" не может ссылать на действие "{0}", поскольку действие "{0}" уже упоминается в другом месте потока операций, и эта ссылка невидима для действия "{1}".  Чтобы действие "{0}" было видимым для действия "{1}", оно должно быть потомком или импортируемым потомком (но не потомком реализации) действия "{2}".  Действие "{0}" первоначально упоминалось в действии "{3}", а действие "{1}" входит в реализацию действия "{2}".
ActivityCannotBeReferencedWithoutTarget=Действие "{1}" не может ссылаться на действие "{0}", так как первое не входит в реализацию другого действия. На действие может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Действие "{0}" объявляется действием "{2}".
ActivityCannotReferenceItself=Действие с отображаемым именем "{0}" пытается ссылаться само на себя. Действие не может быть собственным родителем.
ActivityCompleted=Действие "{0}" (отображаемое имя "{1}", ИД экземпляра "{2}") закончилось в состоянии "{3}".
ActivityDefinitionCannotBeShared=Возможно, объект определения действия "{0}" используется совместно несколькими узлами в рабочем процессе. Многократное использование объекта определения действия в рабочем процессе является ошибкой.
ActivityDelegateAlreadyOpened=Делегат ActivityDelegate "{0}" уже является дочерним для действия "{1}" и не может стать дочерним для действия "{2}".  Делегат может быть возвращен как дочерний только один раз.
ActivityDelegateCannotBeReferenced=Действие "{1}" не может ссылаться на делегат действия с обработчиком "{0}", так как первое не входит в реализацию действия "{2}". На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия с обработчиком "{0}" объявляется действием "{3}".
ActivityDelegateCannotBeReferencedNoHandler=Действие "{0}" не может ссылаться на делегат действия без обработчика, так как первое не входит в реализацию действия "{1}". На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия без обработчика объявляется действием "{2}".
ActivityDelegateCannotBeReferencedWithoutTarget=Действие "{1}" не может ссылаться на делегат действия с обработчиком "{0}", так как первое не входит в реализацию другого действия. На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия с обработчиком "{0}" объявляется действием "{2}".
ActivityDelegateCannotBeReferencedWithoutTargetNoHandler=Действие "{0}" не может ссылаться на делегат действия без обработчика, так как первое не входит в реализацию другого действия. На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия без обработчика объявляется действием "{1}".
ActivityDelegateHandlersMustBeDeclarations=Обработчик для ActivityDelegate, ActivityAction или ActivityFunc не должен быть ссылкой на уже имеющееся в дереве действие. На действие обработчика "{0}" делегата, родителем которого является "{1}", уже ссылается "{2}".
ActivityDelegateNotOpened=Делегат ActivityDelegate "{0}" не находится в открытом состоянии.
ActivityDelegateOwnerEnvironmentMissing=Среда расположения для действия "{0}", объявляющего делегат действия "{1}", не обнаружена.
ActivityDelegateOwnerMissing=Для делегата ActivityDelegate "{0}" необходимо указать элемент рабочего процесса владельца.
ActivityDelegateOwnerNotInParentScope=Элемент Activity, объявляющий делегат ActivityDelegate "{0}", не найден в родительской иерархии текущего выполняемого действия "{1}".
ActivityFailedToOpenBefore=Это действие невозможно открыть, так как ранее при его открытии произошла ошибка.
ActivityHasNoImplementation=Действие "{0}" имеет карту реализации, но не имеет реализации.
ActivityInstanceFixupFailed=Не удалось загрузить рабочий процесс. Данное дерево действий несовместимо с этим экземпляром.
ActivityIsNotRoot=Этот аргумент должен быть корнем определения рабочего процесса.
ActivityIsUncached=Этот метод может быть вызван только после вызова метода CacheMetadata для определения потока операций.
ActivityMapIsCorrupt=Сопоставление из программы действия в экземпляр повреждено в сохраненном экземпляре.
ActivityNotFound=Действие "{0}" не найдено.
ActivityNotICompiledExpressionRoot=Для определения идентификатора выражения требуется действие ICompiledExpressionRoot. Убедитесь, что текущее определение скомпилировано.
ActivityNotPartOfThisTree=Предоставленное действие не было частью данного определения рабочего процесса во время обработки его метаданных. Проблемное действие с именем "{0}" было предоставлено действием с именем "{1}".
ActivityPropertyMustBeSet="{0}" является обязательным свойством действия "{1}".
ActivityPropertyNotSet= Свойство "{0}" операции "{1}" имеет значение null, и она не будет выполнять никаких действий.
ActivityPropertyRequiresName=Свойство "Name" является обязательным для всех свойств ActivityProperty в действии DynamicActivity "{0}".
ActivityPropertyRequiresType=Свойство "Type" является обязательным для всех свойств ActivityProperty в действии DynamicActivity "{0}".
ActivityScheduled=Родительское действие "{0}" (отображаемое имя "{1}", ИД экземпляра "{2}") запланировало дочернее действие "{3}" (отображаемое имя "{4}", ИД экземпляра "{5}").
ActivityTypeMismatch=Действие "{0}" не принадлежит к типу "{1}". При загрузке этого экземпляра необходимо убедиться, что действие с именем "{0}" реализует тип "{1}".
ActivityXamlServiceLineString=Линия
ActivityXamlServicesCompilationFailed=Число сбоев в процессе компиляции: {0}Полные результаты содержатся в свойстве Data этого исключения. Исправьте ошибку в источнике и повторите попытку загрузки.
ActivityXamlServicesRequiresActivity=Действие ActivityXamlServices.Load поддерживает только типы на базе действий. Был предоставлен недопустимый тип ({0}).
AddedIdleArgumentBlockDU=Выражение для добавленного аргумента "{0}" содержит действие "{1}", которое может бездействовать во время выполнения. Чтобы включить динамическое обновление в этом действии, используйте выражение аргумента, которое гарантированно не может быть в бездействии.
AddedIdleExpressionBlockDU=Добавлена переменная по умолчанию или выражение аргумента, которые могут находиться в бездействии во время выполнения.
AddedIdleVariableDefaultBlockDU=Выражение по умолчанию для добавленной переменной "{0}" содержит действие "{1}", которое может бездействовать во время выполнения. Чтобы включить динамическое обновление в этом действии, используйте выражение переменной по умолчанию, которое гарантированно не может быть в бездействии.
AddMatchActivityNewAndOldParentMismatch=Не удается сопоставить новое действие "{0}" со старым действием "{1}", так как их объявители не совпадают. Новое действие объявлено объявителем "{2}", а старое действие объявлено объявителем "{3}".
AddMatchActivityNewParentMismatch=Действие "{0}" не может добавить соответствие для действия "{1}", так как не является его объявителем. Сопоставленное действие объявлено объявителем "{2}".
AddMatchActivityPrivateChild=Не удается добавить соответствие для действия "{0}", так как оно является закрытым потомком. Соответствия могут добавляться только для открытых потомков.
AddMatchVariableNewAndOldParentMismatch=Не удается сопоставить новую переменную "{0}" со старой переменной "{1}", так как их владельцы не совпадают. Новой переменной владеет "{2}", а старой переменной владеет "{3}".
AddMatchVariableNewParentMismatch=Действие "{0}" не может добавить соответствие для переменной "{1}", так как не является ее владельцем. Владельцем соответствующей переменной является "{2}".
AddMatchVariablePrivateChild=Не удается добавить соответствие для переменной "{0}", так как она является закрытой. Соответствия могут добавляться только для открытых переменных.
AddMatchVariableSignatureMismatch=Действие "{0}" не может добавить соответствие переменной, так как сигнатуры этих переменных не совпадают. Сигнатуры, включая имя, тип и модификаторы, должны совпадать. Имя, тип и модификаторы новой переменной: {1}, {2} и {3} соответственно. Имя, тип и модификаторы старой переменной: {4}, {5} и {6} соответственно.
AddValidationErrorMustBeCalledFromConstraint=Метод AddValidationError может вызываться только из поддерева операции {0}.
AECDisposed=К контексту ActivityContext можно обратиться только из области функции, в которую он был передан.
AECForPropertiesHasBeenDisposed=Контекст ActivityContext, создавший данный объект ExecutionProperties, уже удален. К свойствам можно обращаться только из выполняющегося рабочего элемента действия.
AlreadyBoundToInstance=Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand.  Команде требуется несвязанный дескриптор, однако дескриптор InstanceHandle уже привязан к экземпляру.
AlreadyBoundToOwner=Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand.  Команде требуется несвязанный дескриптор, однако дескриптор InstanceHandle уже привязан к владельцу экземпляра.
AlreadySetupNoPersist=Этот элемент рабочего процесса уже настроил несохраняемый блок.  Только один несохраняемый блок может быть настроен элементом рабочего процесса.
AmbiguousVBVariableReference="{0}" является неоднозначной ссылкой на переменную.  Идентификаторы VisualBasic нечувствительны к регистру.
AppDomainUnload=Выгрузка домена приложения. AppDomain.FriendlyName {0}, ProcessName {1}, ProcessId {2}.
ArgumentAlreadyInitialized=Ожидалось, что аргумент "{0}" действия "{1}" будет добавлен динамическим обновлением, но он уже инициализирован.
ArgumentAlreadyInUse=Аргумент "{0}" используется действием "{1}", поэтому он не может использоваться действием "{2}".
ArgumentCannotHaveNullOrVoidType=Действие с параметром DisplayName="{0}" содержит аргумент с именем "{1}", у которого тип null или void.
ArgumentDirectionMismatch=Аргумент, предоставленный для RuntimeArgument "{0}", не может быть привязан из-за несовпадения направления.  Аргумент RuntimeArgument объявляет направление {1}, а данный аргумент имеет направление {2}.
ArgumentDoesNotExist=В этой коллекции не существует аргумента с именем "{0}".
ArgumentDoesNotExistInEnvironment=Аргумент "{0}" не существует в текущей области среды.
ArgumentIsAddedMoreThanOnce=Аргумент "{0}" добавлен в действие "{1}" больше одного раза.
ArgumentLocationExpressionTypeMismatch=Выражение должно иметь тип "{0}", а передан тип "{1}".
ArgumentMustbePropertyofWorkflowElement=Аргумент должен быть одним из свойств класса WorkflowElement.
ArgumentNameRequired=Необходимо задать имя аргумента ArgumentReference или ArgumentValue.
ArgumentNotFound=Не удалось найти аргумент с именем "{0}" для действия, являющегося владельцем этих закрытых дочерних действий.  Параметры ArgumentReference и ArgumentValue должны использоваться только в теле определения действия.
ArgumentNotInTree=Нельзя использовать аргумент типа "{0}". Убедитесь, что он объявлен в действии.
ArgumentNullOrEmpty=Аргумент {0} имеет значение null или является пустым.
ArgumentNumberRequiresTheSameAsParameterNumber=Число аргументов и число параметров типа "{0}" должны совпадать.
ArgumentRequired=Требуется содержимое аргумента в коллекции "{0}" аргументов "{1}".
ArgumentTypeCannotBeNull=Типом аргумента не может быть null.
ArgumentTypeMismatch=Не удается привязать аргумент, указанный для RuntimeArgument "{0}", из-за несоответствия типов.  Аргумент RuntimeArgument объявляет тип {1}, а аргумент имеет тип {2}.  Типы должны совпадать.
ArgumentTypeMustBeCompatible=Тип аргумента должен быть совместим с типом данного параметра ArgumentReference или ArgumentValue.  Аргумент "{0}" имеет тип {1}, а ожидаемый тип - {2}.
ArgumentValueExpressionTypeMismatch=Аргументу требуется тип ResultType "{0}", а предоставлено действие с типом результата "{1}".
ArgumentViolationsFound=Обнаружены нарушения в действии "{0}". Были обнаружены следующие нарушения:    {1}
AssemblyReferenceIsImmutable=Встроенные, используемые по умолчанию AssemblyReferences нельзя изменить.
AsyncCallbackThrewException=Асинхронный обратный вызов сформировал исключение.
AsyncEventArgsCompletedTwice=Реализация "{0}" интерфейса AsyncEventArgs пытается выполнить одну операцию несколько раз. Возможно, это вызвано неверной реализацией интерфейса AsyncEventArgs или другого кода расширяемости, вызывающего событие AsyncCallback несколько раз.
AsyncEventArgsCompletionPending=Реализация "{0}" интерфейса AsyncEventArgs пытается задать состояние ожидания несколько раз, не завершая ожидающей операции. Возможно, это вызвано неверной реализацией интерфейса AsyncEventArgs или другого кода расширяемости, вызывающего событие Set() несколько раз.
AsyncMethodsMustAllBeStaticOrInstance=Все асинхронные методы должны быть статическими методами или методами экземпляров.
AsyncMethodsMustFromSameType=Асинхронные методы должны быть одного типа.
AsyncResultAlreadyEnded=Метод End нельзя вызывать дважды для AsyncResult.
AsyncResultCompletedTwice=Реализация "{0}" интерфейса IAsyncResult пытается выполнить одну операцию несколько раз. Возможно, это вызвано неверной реализацией интерфейса IAsyncResult или другого кода расширяемости в приложении - например, интерфейс IAsyncResult возвращает неверные значения CompletedSynchronously или несколько раз вызывает AsyncCallback.
AsyncTransactionException=В области TransactionScope, используемой для включения транзакции в асинхронную операцию, произошло исключение.
BadCopyToArray=Не удалось скопировать элементы словаря в указанный массив. Это может быть вызвано одной или несколькими следующими ошибками: массив имеет слишком много измерений; индекс находится после конца массива, в массиве недостаточно места.
BadWorkflowIdentityFormat=Недопустимый формат WorkflowIdentity. Идентификатор WorkflowIdentity должен иметь формат "имя; Version=версия; Package=пакет". Указание версии и пакета необязательно.
BeforeInitializeComponentXBTExtensionResourceNotFound=Предполагалось, что ресурс будет создан расширением построения задания XAML BeforeInitializeComponent. Этот ресурс не найден. Перестройте проект.
BeginExecuteMustNotReturnANullAsyncResult=AsyncCodeActivity.BeginExecute не должен возвращать значение NULL для IAsyncResult.
BeginExecuteMustUseProvidedStateAsAsyncResultState=Действие AsyncCodeActivity.BeginExecute должно возвращать интерфейс IAsyncResult, где IAsyncResult.AsyncState — это объект состояния, предоставляемый средой выполнения.
BinaryExpressionActivityRequiresArgument={0} необходимо задать до начала использования {1} действия "{2}".
BindLockRequiresCommandFlag=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock или CreateBindReclaimedLockException в недействительное время. Эти методы могут вызываться только во время обработки команды, которая может получить блокировку экземпляра. Переключитесь в допустимый поставщик сохраняемости или переопределите реализацию InstancePersistenceCommand так, чтобы возвращать значение true из AutomaticallyAcquiringLock.
BindReclaimedLockException=Это исключение не является ошибкой, и его не следует обрабатывать.  Он может вызываться в реализации InstanceStore.TryCommand, BeginTryCommand или EndTryCommand в поставщике сохраняемости, чтобы указать на попытку восстановления блокировки для версии, указанной в вызове InstancePersistenceContext.CreateBindReclaimedLockException.
BindReclaimSucceeded=Реализация InstanceStore в поставщике сохраняемости успешно отменила команду. Потерянная блокировка была восстановлена, и команда отменена посредством InstancePersistenceContext.CreateBindReclaimedLockException.
BlockedUpdateInsideActivityUpdateByUserError=Автор обновление запретил обновление внутри этого выполняющегося действия.
BlockedUpdateInsideActivityUpdateError=Динамическое обновление для данного действия заблокировано.
BodyCannotBeNull=Значение Body в описании письма не может быть равно null. Задайте правильное значение для OperationDescription.MessageDescription.Body.
BookmarkAlreadyExists=Закладка с именем "{0}" уже существует.
BookmarkNotFoundGeneric=Не удалось найти запрошенную закладку.
BookmarkNotRegistered=Закладка {0} в данный момент не зарегистрирована в расширении компенсации.
BookmarkScopeAlreadyInitialized=Невозможно инициализировать область закладок, так как она уже инициализирована.
BookmarkScopeHasBookmarks=Регистрация указанной области закладок не может быть отменена, так как она содержит неразмещенные закладки.
BookmarkScopeInitialized=Объект BookmarkScope с идентификатором TemporaryId: "{0}" инициализирован идентификатором "{1}".
BookmarkScopeNotFound=Не удается найти область закладок с идентификатором "{0}".
BookmarkScopeNotRegisteredForInitialize=Указанную область закладок невозможно инициализировать, так как она не зарегистрирована.
BookmarkScopeNotRegisteredForUnregister=Регистрация указанной области закладок не может быть отменена, так как она не зарегистрирована.  
BookmarkScopesRequireKeys=Для областей закладок требуется узел, который поддерживает управление ключами.  Используемый узел не поддерживает управление ключами.  Если используются объекты WorkflowApplication или WorkflowInvoker, рассмотрите вместо этого использование WorkflowServiceHost.
BookmarkScopeWithIdAlreadyExists=Указанная область закладок не может быть инициализирована с идентификатором "{0}", так как уже существует область закладок с таким идентификатором.
BookmarksOnlyResumableWhileIdle=Действие TryScheduleBookmarkResumption можно вызвать только во время простоя среды выполнения.
BufferAllocationFailed=Не удалось выделить буфер управляемой памяти размером {0} байт. Возможно, не хватает доступной памяти.
BufferedOutputStreamQuotaExceeded=Превышена квота на размер для этого потока ({0}).
BufferedReceiveBehaviorMultipleUse=Экземпляр BufferedReceiveServiceBehavior не может быть добавлен в класс WorkflowServiceHost, так как он уже добавлен в другой экземпляр класса WorkflowServiceHost. Создавайте новый экземпляр BufferedReceiveServiceBehavior для каждого нового класса WorkflowServiceHost.
BufferedReceiveBehaviorUsedWithoutProperty=Значение BufferedReceiveServiceBehavior должно использоваться с определением потока операций, поддерживающим обработку BufferedReceive. Чтобы включить обработку BufferedReceive, вызовите метод WorkflowService.AllowBufferedReceive.
BufferedReceiveRequiresReceiveContext=Операция с именем "{0}" должна быть включена, чтобы использовать режим ManualAcknowledgement метода ReceiveContext, когда используется BufferedReceiveServiceBehavior.
BufferIsNotRightSizeForBufferManager=Этот буфер нельзя вернуть диспетчеру буферов из-за неверного размера.
BufferOutOfOrderMessageNoBookmark=Операция "{1}" в экземпляре службы "{0}" не может быть выполнена сейчас. Следующая попытка будет предпринята, когда экземпляр службы будет готов к обработке именно этой операции.
BufferOutOfOrderMessageNoInstance=Операция "{0}" не может быть выполнена сейчас. Следующая попытка будет предпринята, когда экземпляр службы будет готов к обработке именно этой операции.
BufferPoolAllocation=Выделение {0} байт пулом.
BufferPoolChangeQuota=BufferPool размером {0}, изменение квоты на {1}.
BusyCountTraceFormatString=Идентификатор экземпляра потока операций {0}
CacheRootMetadataStart=CacheRootMetadata запущено для действия "{0}"
CacheRootMetadataStop=CacheRootMetadata остановлено для действия {0}.
CacheSettingsLocked=Параметры кэша неизменяемы, так как расширение уже добавлено в экземпляр рабочего процесса или в коллекцию расширений узлов.
CallbackExceptionFromHostAbort=Вызов OnRequestAbort для WorkflowInstance "{0}" привел к вызову исключения, которое признано неустранимым. Подробные сведения см. во внутреннем исключении.
CallbackExceptionFromHostGetExtension=Вызов OnGetExtension для WorkflowInstance "{0}" привел к вызову исключения, которое признано неустранимым. Подробные сведения см. во внутреннем исключении.
CancellationHandlerFatalException=Обработчик отмены "{0}" создал необработанное исключение. Возможно, процесс отмены находится в несовместимом состоянии, рабочий процесс был прерван.
CanInduceIdleActivityInArgumentExpression=Аргумент "{0}" действия "{1}" привязан к выражению, содержащему действие "{2}". Действие "{2}" может привести выражение в состояние простоя во время оценки. Если выражения аргументов действия "{1}" изменяют общее состояние, то простой во время оценки может привести к непредвиденным значениям аргументов.
CanInduceIdleNotSpecified=Операция "{0}" недопустима. Операция NativeActivity создала производные асинхронные операции, вызывая один из перегруженных методов CreateBookmark, определенных в System.Activities. NativeActivityContext должен переопределить свойство CanInduceIdle и возвратить true.
CannotAcquireLockDefault=Выполнение InstancePersistenceCommand прервано, поскольку экземпляр заблокирован другим владельцем. Эта ошибка обычно происходит из-за того, что экземпляр загружается на другом узле.
CannotAcquireLockSpecific=Выполнение InstancePersistenceCommand прервано, поскольку экземпляр "{0}" заблокирован другим владельцем. Эта ошибка обычно происходит из-за того, что экземпляр загружается на другом узле.
CannotAcquireLockSpecificWithOwner=Выполнение InstancePersistenceCommand прервано, поскольку экземпляр "{0}" заблокирован другим владельцем. Эта ошибка обычно происходит из-за того, что экземпляр загружается на другом узле. Владелец экземпляра или узел, удерживающий блокировку экземпляра, имеет идентификатор "{1}".
CannotAddHandlesUpdateError=Действие добавило новую переменную, тип которой является производным от класса Handle.
CannotAddOrRemoveWithChildren=Действие не может добавить или удалить свойства выполнения рабочего процесса пока выполняются его дочерние действия.
CannotCallAbortInstanceFromWorkflowThread=Действие AbortInstance не может быть вызвано из потока рабочего процесса, так как это может привести к несогласованному состоянию.
CannotChangeAbortInstanceFlagAfterPropertyRegistration=Значение флага AbortInstanceOnTransactionFailure не может быть изменено после выполнения соответствующего классу RuntimeTransactionHandle действия IPropertyRegistrationCallback.Register.
CannotChangeMatchesInImplementation=Новые соответствия невозможно добавлять в закрытые реализации рабочего процесса, для которых строится карта обновления.
CannotCompleteRuntimeOwnedTransaction=Текущая транзакция была настроена средой выполнения и может быть завершена только этой средой.  Транзакция, настроенная средой выполнения, обычно является результатом вызова API в методе WorkflowInvoker во время существования включающей транзакции.
CannotCompleteWithKeys=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о завершении экземпляра, когда с ним связаны активные ключи. Перед завершением экземпляра необходимо завершить все ключи, связанные с ним.
CannotConvertObject=Не удается преобразовать объект "{0}" в тип "{1}".
CannotCreateContextWithNullId=В аргументе instanceId метода InstanceStore.CreateInstanceHandle нельзя указывать нулевые идентификаторы, например Guid.Empty.
CannotCreateMessageFault=Не удается создать MessageFault.
CannotCreateOwnerWithoutIdentity=Не удалось создать владельца экземпляра по умолчанию без WorkflowIdentity. Чтобы создать владельца, укажите идентификатор определения или выберите WorkflowIdentityFilter.Any.
CanNotDefineNullForAPromotion=Коллекция продвижения {0} содержит значение NULL для имени продвижения {1}.
CannotDereferenceNull=Не удается создать левостороннее значение из заданного выражения со свойством "{0}", так как значением целевого объекта является null.
CannotEnlistMultipleTransactions=Уже существует транзакция, участвующая в рабочем процессе. Одновременное участие нескольких транзакций недопустимо.
CanNotFindSymbolResolverInWorkflowInstanceExtensions=Не удалось обнаружить символьный разрешитель в коллекции расширений экземпляра рабочего процесса.
CannotGenerateSchemaForXmlSerializable="{0}" являются внутренними данными среды выполнения, они не поддерживают формирование схемы.
CannotGetValueOfOutArgument=Невозможно получить значение строго выходного аргумента.
CannotInvokeBindingFromNonBinding=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она пытается выполнить команду, которая может получить блокировку при обработке команды, которая не получает блокировку. Это исключение может вызываться, если метод InstancePersistenceContext.Execute или InstancePersistenceContext.BeginExecute вызывается с командой, для которой InstancePersistenceCommand.AutomaticallyAcquiringLock возвращает значение true, при обработке команды, для которой возвращается значение false. Используйте поставщик сохраняемости, который работает иначе, или переопределите AutomaticallyAcquiringLock в одной из команд, чтобы возвращать нужное значение.
CannotInvokeOpenedActivity=Это действие не может быть вызвано, так как оно не было открыто перегруженным методом Invoke, принимающим интерфейс IDictionary строки и объект.
CannotInvokeTransactionalFromNonTransactional=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она пытается выполнить транзакционную команду при обработке нетранзакционной команды. Это исключение может вызываться, если метод InstancePersistenceContext.Execute или InstancePersistenceContext.BeginExecute вызывается с командой, для которой InstancePersistenceCommand.IsTransactionEnlistmentOptional возвращает значение false, при обработке команды, для которой возвращается значение true. Используйте поставщик сохраняемости, который работает иначе, или переопределите IsTransactionEnlistmentOptional в одной из команд, чтобы возвращать нужное значение.
CannotModifyCatchAfterOpen=Это действие Catch уже открыто и не может быть изменено. Действия Catch могут быть изменены только во время разработки.
CannotMoveChildAcrossDifferentFlowNodeTypes=Блок-схема не поддерживает динамическое обновление, если дочернее действие перемещено из одного типа FlowNode в другой тип FlowNode.
CannotNestTransactedReceiveScopeWhenAmbientHandleIsSuppressed=Транзакция среды выполнения подавлена. Выполнение действия TransactedReceiveScope "{0}" при подавлении транзакции среды выполнения не поддерживается.
CannotNestTransactionScopeWhenAmbientHandleIsSuppressed=Транзакция среды выполнения в данный момент подавляется. Выполнение действия TransactedScope "{0}" при подавлении транзакции среды выполнения не поддерживается.
CannotPerformOperationFromHandlerThread=Операции WorkflowApplication не могут быть выполнены из обработчиков событий.
CannotPerformOperationOnHandle=Операция не может быть выполнена для переменных подтипов Handle.
CannotPersistInsideIsolation=Действия материализации (Persist) не могут содержаться в блоках изоляции.
CannotPersistInsideNoPersist=Действия материализации (Persist) не могут содержаться в несохраняемых блоках.
CannotPersistWhileDetached=Экземпляр не может быть сохранен, так как он не является владельцем блокировки.  Предыдущий вызов действия Persist со значением разблокировки true отвечал за разблокировку.
CannotPromoteAsSqlVariant=Тип данных "{0}" для свойства с повышенным уровнем "{1}" не поддерживается в SQL. Измените тип данных на поддерживаемый или повышайте свойство в виде двоичного значения.
CannotPromoteXNameTwiceInPromotion=Элемент XName "{0}" продвигается несколько раз при продвижении "{1}". Повторные XName в рамках одного продвижения не разрешаются.
CannotPropagateExceptionWhileCanceling=При отмене действия "{0}" с идентификатором {1} возникло или распространилось исключение.
CannotRemoveExecutingActivityUpdateError=Не удается удалить действие "{0}: {1}", так как оно в настоящий момент выполняется.
CannotReplaceTransaction=Внешняя транзакция (System.Transactions.Transaction.Current) не соответствует транзакции, используемой в данном эпизоде выполнения.  На протяжении всего эпизода выполнения можно использовать только одну транзакцию.
CannotResetPropertyInDataContext=Значение свойства в контексте WorkflowDataContext невозможно сбросить.
CannotSaveOriginalValueForActivity=Действие может сохранять исходные значения только для открытых или импортированных потомков или для обработчиков делегатов.
CannotSaveOriginalValueForNewActivity=Не удается сохранить исходное значение для действия "{0}", так как оно не существовало в исходном определении рабочего процесса.
CannotSaveOriginalValuesForReferencedChildren=Это действие неправильно обрабатывает обновления, если находится внутри реализации действия. Оно попыталось сохранить исходные значения для ссылок на импортированных потомков.
CannotScheduleChildrenWhileEnteringIsolation=Дочерние действия невозможно запланировать при настройке блока изоляции. Дождитесь вызова OnEntered BookmarkCallback перед планированием дочерних действий.
CannotSerializeExpression=Не удалось сериализовать выражение типа "{0}".
CannotSerializeVariableExpression=Не удалось сериализовать выражение, так как подвыражения доступа к переменной сформированы неправильно или не распознаны.
CannotSetRuntimeTransactionInNoPersist=В среде выполнения невозможно задать транзакцию действием, содержащимся в несохраняемой области.  Сохранение запрещено действием-предком.
CannotSetupIsolationInsideIsolation=Невозможно настроить блок изоляции, так как он будет содержаться в другом блоке изоляции.  Блоки изоляции не могут быть вложенными.
CannotSetupIsolationInsideNoPersist=Невозможно настроить блок изоляции, так как он будет содержаться в несохраняемом блоке.
CannotSetupIsolationWithChildren=Блок изоляции не может быть настроен, если существуют выполняющиеся дочерние действия.
CannotSetValueOfInArgument=Невозможно присвоить значения входящим аргументам.
CannotSetValueToLocation=В значении типа "{0}" нельзя установить расположение с именем "{1}", поскольку оно имеет тип "{2}".
CannotSpecifyBothConnectionStringAndName=Нельзя одновременно задавать свойства connectionString и connectionStringName.
CannotSuppressAlreadyRegisteredHandle=Не удается изменить значение свойства SuppressTransaction в уже зарегистрированном классе RuntimeTransactionHandle.
CannotUnregisterDefaultBookmarkScope=Невозможно удалить область закладок, так как она является областью закладок по умолчанию для экземпляра.
CannotUnregisterNullBookmarkScope=Невозможно отменить регистрацию области закладок со значением null.
CannotUpdateEnvironmentInTheMiddleOfResolvingArguments=Аргументы или переменные нельзя добавлять, удалять или перегруппировывать, если экземпляр находится в процессе разрешения аргументов.
CannotUpdateEnvironmentInTheMiddleOfResolvingVariables=Аргументы или переменные нельзя добавлять, удалять или перегруппировывать, если экземпляр находится в процессе разрешения переменных.
CannotUpdateLoadedInstance=Не удалось обновить экземпляр WorkflowInstance "{0}", так как он уже загружен. Перед обновлением экземпляра его необходимо приостановить.
CannotUseAddServiceEndpointOverloadForWorkflowServices=Класс WorkflowServiceHost не поддерживает добавление конечных точек приложений с использованием перегруженной версии AddServiceEndpoint ServiceEndpoint endpoint).  Используйте одну из перегруженных версий "XName serviceContractName" или "string implementedContract", чтобы добавить конечные точки приложений в класс WorkflowServiceHost.
CannotUseInputsWithLoad=Входные данные рабочего процесса не могут использоваться с операциями Load и LoadRunnableInstance, поскольку они предоставляются только для новых экземпляров.
CannotValidateNullObject=Аргумент ToValidate действия {0} с именем "{1}" разрешен в пустое значение.  Переданный объект не должен быть пустым.
CannotWaitForIdleSynchronously=Операция закончилась с ошибкой, так как была вызвана из обработчика, когда рабочий процесс не находился в состоянии простоя.  Для выполнения операции требуется, чтобы рабочий процесс находился в состоянии простоя, и рабочий процесс не может ее выполнить, если она находится в обработчике событий.
CanOnlyAbortDirectChildren=Действие может прерывать только свои прямые дочерние действия.
CanOnlyCancelDirectChildren=Действие может отменять только свои прямые дочерние действия.
CanOnlyGetOwnedArguments=Действие может получать расположение только тех аргументов, владельцем которых является.  Действие "{0}" пытается получить расположение аргумента "{1}", владельцем которого является действие "{2}".
CanOnlyScheduleDirectChildren=Действие может планировать только своих непосредственных потомков. Действие "{0}" пытается запланировать действие "{1}", которое является потомком действия "{2}".
CantFindTimerExtension=Расширение TimerExtension должно быть добавлено в коллекцию расширений.
CatchOrFinallyExpected=Действию TryCatch "{0}" требуется аргумент Catch или Finally.
ChangeConditionalTransitionToUnconditionalBlockDU=StateMachine не поддерживает динамическое обновление, если условный переход становится безусловным после обновления.
ChangeTransitionTypeDuringTransitioningBlockDU=StateMachine не поддерживает динамическое обновление, если состояние меняется, а текущий переход стал условным.
ChangingTriggerOrUseOriginalConditionActionBlockDU=StateMachine не поддерживает динамическое обновление, если триггер существующего перехода изменен, или действие Condition или Action переназначено новому переходу.
CleanupInProgress=Блокировка SqlWorkflowInstanceStore не может обработать команду, поскольку в настоящее время выполняется очистка хранилища. Дождитесь окончания очистки и повторите попытку.
CollectionActivityRequiresCollection=Свойство "Collection" элемента "{0}" не инициализировано.
ColumnNumberTooLarge=Указанный номер столбца для действия {0} слишком велик и не поддерживается системой частичной проверки
CommandExecutionCannotOverlap=Для одного InstanceHandle в каждый момент времени может выполниться только одна команда. Не вызывайте метод Execute или BeginExecute для InstanceStore, пока не завершится предыдущая команда, выполняющаяся для этого InstanceHandle.
CompensableActivityAlreadyConfirmedOrCompensated=Действие CompensableActivity, указанное маркером CompensationToken "Target", уже подтверждено или компенсировано.
CompensableActivityInsideTransactedReceiveScope=Действие CompensableActivity нельзя вложить в область TransactedReceiveScope.
CompensableActivityInsideTransactionScopeActivity=Действие CompensableActivity не может быть вложено в действие TransactionScope.
CompensateWithNoTargetConstraint=Использование действия Compensate без указания аргумента Target допускается только в обработчиках Compensation, Confirmation или Cancellation.
CompensateWithoutCompensableActivity=Действие компенсации "{0}" может быть использовано, только если действие CompensableActivity в рабочем процессе уже выполнено.
CompensationHandlerFatalException=Необработанное исключение создано обработчиком компенсации, принадежащим "{0}". Работа по компенсации может быть в несогласованном состоянии, рабочий процесс прерван.
CompensationState=CompensableActivity "{0}" находится в состоянии "{1}".
CompiledExpressionIdNotFound=Не удалось найти идентификатор выражения для "{0}". Убедитесь, что текущее определение скомпилировано.
CompiledExpressionsActivityException=TextExpressionCompiler: Исключение типа "{0}" возникло при обработке действия "{1}": "{2}".
CompiledExpressionsCacheMetadataException=CacheMetadata для действия "{0}" вызвало "{1}".
CompiledExpressionsDuplicateName="{0}" является неоднозначной ссылкой на переменную. Переименуйте идентификатор.
CompiledExpressionsIgnoringInvalidIdentifierVariable=TextExpressionCompiler: Пропуск переменной "{0}". Идентификатор не является допустимым для текущего языка.
CompiledExpressionsIgnoringUnnamedVariable=TextExpressionCompiler: Пропуск переменной без имени.
CompiledExpressionsNoCompiledRoot=Не удалось найти экземпляр действия, соответствующий действию "{0}". Перекомпилируйте рабочий процесс.
CompiledLocationNoDefaultConstructor=Скомпилированные выражения требуют наличия конструктора по умолчанию в локальном корне. Добавьте конструктор по умолчанию для типа "{0}".
CompiledLocationReferenceGetLocation=CompiledLocationReference никогда не следует использовать для доступа к расположению.
CompilerError=Обнаружены ошибки компилятора.
CompilerErrorSpecificExpression=Обнаружены ошибки компилятора при обработке выражения "{0}".{1}
CompileVbExpressionStart=Компиляция выражения VB "{0}"
CompileVbExpressionStop=Компиляция выражения VB завершена.
CompleteBookmarkWorkItem=Выполнение элемента BookmarkWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}". BookmarkName: {3}, BookmarkScope: {4}.
CompleteCancelActivityWorkItem=Выполнение элемента CancelActivityWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".
CompleteCompletionWorkItem=Выполнение элемента CompletionWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}". Выполнение элемента Activity "{3}" завершено, DisplayName: "{4}", InstanceId: "{5}".
CompletedMustNotHaveAssociatedKeys=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке экземпляра, который находится в состоянии InstanceState.Completed и для которого не завершены связанные ключи.
CompleteExecuteActivityWorkItem=Выполнение элемента ExecuteActivityWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".
CompleteFaultWorkItem=Выполнение элемента FaultWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}". В элементе Activity "{3}" произошло исключение, DisplayName: "{4}", InstanceId: "{5}".
CompleteRuntimeWorkItem=Выполнение рабочего элемента среды выполнения для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".
CompleteTransactionContextWorkItem=Выполнение элемента TransactionContextWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".
CompletionConditionSetButNoBody=Недопустима ситуация, когда в объекте ParallelForEach значение свойства CompletionCondition равно null, а значение свойства Body не равно null. Необходимо предусмотреть присвоение свойству Body объекта ParallelForEach "{0}" действия с пустой последовательностью (Sequence).
ConfirmationHandlerFatalException=Необработанное исключение создано обработчиком подтверждений, принадежащим "{0}". Работа по подтверждению может быть в несогласованном состоянии, рабочий процесс прерван.
ConfirmWithNoTargetConstraint=Использование действия Confirm без указания аргумента Target допускается только в обработчиках Compensation, Confirmation или Cancellation.
ConfirmWithoutCompensableActivity=Действие подтверждения "{0}" может быть использовано, только если действие CompensableActivity в рабочем процессе уже выполнено.
ConflictingValueName=Имя свойства "{0}" (XName) для значения, предоставленного в метод DurableInstanceManager.AddInstanceOwnerValues, конфликтует с именем уже добавленного значения. Убедитесь, что имена всех значений, передаваемых в метод AddInstanceOwnerValues, уникальны. Данная ошибка может происходить по причине конфликта настроенных поведений служб.
ConnectionStringNameWrong=Не удалось найти строку соединения для соединения "{0}".
ConstructorInfoNotFound=Данные соответствующего конструктора не обнаружены в типе "{0}".
ConstVariableCannotBeSet=Это расположение отмечено как константа, поэтому его значение невозможно изменить.
ContextAlreadyBoundToInstance=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindInstance, чтобы задать идентификатор экземпляра InstanceHandle, который уже привязан к экземпляру. Дескриптор InstanceHandle в течение времени своего существования может привязываться только к одному экземпляру.
ContextAlreadyBoundToLock=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, чтобы задать версию заблокированного экземпляра InstanceHandle, который уже привязан к блокировке. Дескриптор InstanceHandle в течение времени своего существования может привязываться только к одной блокировке.
ContextAlreadyBoundToOwner=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindOwner, чтобы задать владельца InstanceHandle, который уже привязан к владельцу. Дескриптор InstanceHandle в течение времени своего существования может привязываться только к одному владельцу.
ContextMismatchInContextAndCallBackContext=CorrelationCallbackContext и CorrelationContext заданы, однако указанные в них контексты не совпадают.
ContextMustBeBoundToInstance=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock или CreateBindReclaimedLockException, чтобы привязать InstanceHandle к версии блокировки экземпляра, однако InstanceHandle не привязан к экземпляру. Перед привязкой дескриптора InstanceHandle к блокировке его нужно привязать к экземпляру.
ContextMustBeBoundToOwner=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock или CreateBindReclaimedLockException, чтобы привязать InstanceHandle к версии блокировки экземпляра, однако InstanceHandle не привязан к владельцу. Перед привязкой дескриптора InstanceHandle к блокировке его нужно привязать к владельцу.
ContextNotFromThisStore=Аргумент handle, передаваемый методам InstanceStore.Execute и InstanceStore.BeginExecute, должен быть создан путем вызова метода CreateInstanceHandle для этого же экземпляра InstanceStore.
ContractInferenceValidationForTransactionFlowBehavior=Поведению TransactionFlow операции необходимо присвоить значение Allowed.
ContractNotFoundInAddServiceEndpoint=Не удается добавить конечную точку, поскольку не удается найти описание контракта ContractDescription с параметрами Name="{0}" и Namespace="{1}".
ControllerInvalidBeforeInitialize=WorkflowInstance.Controller доступен только после вызова Initialize.
ConvertVariableToValueExpressionFailed=Не удается преобразовать переменную типа "{0}" в действие типа "{1}".
CopyToIndexOutOfRange=Индекс массива должен быть положительным.
CopyToNotEnoughSpaceInArray=У предоставленного массива недостаточно емкости для хранения значений.
CopyToRankMustBeOne=Предоставленный массив имеет несколько измерений. Ранг массива должен быть равен единице, чтобы его можно было использовать с методом CopyTo.
CorrelatedContextRequiredForAnonymousSend=Действие Send либо должно быть настроено с помощью конечной точки, либо скоррелировано с ранее установленным с помощью свойства CorrelatesWith контекстом.
CorrelationHandleInUse=Дескриптор CorrelationHandle уже используется в экземпляре BookmarkScope "{0}", поэтому его нельзя использовать в экземпляре BookmarkScope "{1}".
CorrelationResponseContextShouldNotBeNull=Контекст CorrelationResponse не должен быть равен null. Значение null может означать, что дескриптор корреляции настроен неправильно.
CouldNotResolveNamespacePrefix=Не удается разрешить префикс пространства имен "{0}".
CreateBookmark=Для элемента Activity "{0}" создана закладка Bookmark, DisplayName: "{1}", InstanceId: "{2}".  BookmarkName: {3}, BookmarkScope: {4}.
CreateBookmarkScope=Создан объект BookmarkScope: {0}.
CreateBookmarkScopeFailed=Данный класс BookmarkScopeHandle уже сопоставлен BookmarkScope.
CreateWorkflowServiceHostStart=Запуск CreateWorkflowServiceHost
CreateWorkflowServiceHostStop=Остановка CreateWorkflowServiceHost
CSharpExpressionsMustBeCompiled=Выражения CSharp должны компилироваться.
CurrentOperationCannotCreateInstance=Отсутствует контекст, связанный с входящим сообщением для службы, а текущая операция не снабжена атрибутом "CanCreateInstance = true". Для взаимодействия с этой службой проверьте, поддерживает ли входящая привязка протокол контекста и был ли инициализирован допустимый контекст.
DanglingReceive=В потоке операций отсутствует операция Receive, парная с операцией SendReply. Убедитесь, что каждой операции SendReply соответствует операция Receive, присутствующая в потоке операций.
DatabaseUpgradeRequiredForCommand=Хранилище SqlWorkflowInstanceStore содержит версию базы данных "{0}". Команда InstancePersistenceCommand "{1}" не может быть запущена для этой версии базы данных. Обновите базу данных до "{2}".
DebugInfoCannotEvaluateExpression=Невозможно вычислить выражение "{0}" в текущем контексте.
DebugInfoExceptionCaught=При вычислении {0} возникло исключение {1}.
DebugInfoNotSkipArgumentResolution=*** значение не SkipArgumentResolution ***
DebugInfoTryGetValueFailed=*** действие TryGetValue завершилось с ошибкой ***
DebugInstrumentationFailed=Инструментирование отладчика завершилось с ошибкой.  Причина: {0}.
DebugSymbolChecksumValueInvalid=Контрольная сумма, указанная в качестве отладочного символа, не прошла частичную проверку.
DefaultAbortReason=Рабочий процесс прерван.
DefaultCancelationRequiresCancelHasBeenRequested=Логика отмены по умолчанию требует, чтобы параметр HasCancelBeenRequested имел значение true.  Метод Cancel действия NativeActivity должен вызываться только средой выполнения.
DefaultCreateOnlyReason=Поток операций создан со значением true для свойства WorkflowCreationContext.CreateOnly.
DefaultInvalidWorkflowExceptionMessage=Недопустимая структура определения рабочего процесса. Используйте класс ActivityValidationServices, чтобы просмотреть все нарушения.
DefaultSuspendReason=Рабочий процесс был приостановлен через контрольную конечную точку.
DefaultTerminationReason=Рабочему процессу был отправлен запрос на завершение.
DefaultWorkflowApplicationExceptionMessage=Операция не может быть выполнена, поскольку она не разрешена в текущем состоянии класса WorkflowApplication.
DelegateArgumentAlreadyInUseOnActivity=Объект DelegateArgument "{0}" не может быть использован в действии "{1}", так как он уже используется действием "{2}".
DelegateArgumentChangeBlockDU=Это действие является обработчиком ActivityDelegate, аргументы которого изменились.
DelegateArgumentDoesNotExist=Объект DelegateArgument "{0} не существует в данной среде.
DelegateArgumentMustBeReferenced=Объект DelegateArgument "{0}" перед использованием должен быть включен в класс ActivityDelegate действия.
DelegateArgumentMustBeSet=Объект DelegateArgument должен быть задан до вызова метода CacheMetadata.
DelegateArgumentNotVisible=Объект DelegateArgument ("{0}"), на который производится ссылка, невидим в данной области.
DelegateArgumentTypeInvalid=DelegateArgument "{0}" нельзя использовать в выражении типа "{1}", поскольку он относится к несовместимому типу "{2}".
DelegateHandlersCannotBeScheduledDirectly=Действие "{0}" попыталось напрямую запланировать действие-обработчик "{1}" ActivityDelegate.  Обработчики ActivityDelegate невозможно запланировать напрямую.  Вместо этого следует запланировать выполнение самого делегата ActivityDelegate.
DelegateInArgumentTypeMismatch=Недействительный тип аргумента для входа делегата с именем "{0}".  Вход делегата имеет тип "{1}, а аргумент имеет тип "{2}".  Тип аргумента должен приводиться к типу входа делегата.
DelegateOutArgumentTypeMismatch=Недействительный тип аргумента для выхода делегата с именем "{0}".  Выход делегата имеет тип "{1}, а аргумент имеет тип "{2}".  Тип выхода делегата должен приводиться к типу аргумента.
DelegateParameterCannotBeModifiedAfterOpen=Параметр ActivityDelegateParameter "{0}" нельзя изменять. Делегат ActivityDelegate, который его использует, заблокирован. Делегат ActivityDelegate блокируется при вызове метода Invoke для элемента WorkflowElement, который является его владельцем, или при создании из него экземпляра WorkflowInstance.
DelegateParameterDirectionalityMismatch=Направленностью параметра делегата действия "{0}" в словаре DelegateParameters является "{1}". Ожидаемой направленностью является "{2}".
DictionaryIsReadOnly=Этот словарь доступен только для чтения и не может быть изменен.
DifferentContractsSameConfigName=У двух различных контрактов совпадает имя ConfigurationName.
DifferentWorkflowServiceNameNotSupported=Имя WorkflowService {0} в дополнительных версиях не соответствует имени {1} WorkflowService по умолчанию.
DirectLambdaParameterReference=Невозможно сериализовать выражения с прямыми ссылками на лямбда-параметр.  Возможно, ссылка на переменную сформирована неправильно.
DirectoryAborted=Работа каталога загруженных экземпляров прекращена. Выполняется непредвиденное завершение работы службы.
DispatchOperationInInvalidState=Поведению WorkflowOperationBehavior не удается применить поведение диспетчера, поскольку экземпляр операции DispatchOperation находится в недопустимом состоянии.
DoNotCompleteTryCommandWithPendingReclaim=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она завершила обработку запроса TryCommand, пока была активна попытка восстановления блокировки. Используйте поставщик сохраняемости, который не возвращает значение из TryCommand и не вызывает исключение в пределах TryCommand, завершите результат IAsyncResult, возвращенный из BeginTryCommand, перед завершением IAsyncResult, возвращенного из BeginBindReclaimedLock, или завершите работу перед вызовом исключения, возвращенного из CreateBindReclaimedLockException.
DoNotSupportArrayIndexerOnNonArrayType=Индексатор ArrayIndexer не поддерживается в типе {0}, так как он не является типом массива.
DoNotSupportArrayIndexerReferenceWithDifferentArrayTypeAndResultType=Класс ArrayIndexer в качестве LValue с типом массива {0} и типом результата {1} не поддерживается, поскольку они не одинаковы.
DoNotSupportArrayIndexerValueWithIncompatibleArrayTypeAndResultType=Класс ArrayIndexer в качестве правостороннего значения с типом элемента массива {0} и типом результата {1} не поддерживается, так как {0} не совместимо с {1}.
DoNotSupportArrayIndexerWithDifferentArrayTypeAndResultType=Индексатор ArrayIndexer с типом массива {0} и типом результата {1} не поддерживается, так как они не совпадают.
DoNotSupportArrayIndexerWithNonIntIndex=Индексатор ArrayIndexer с типом индекса {0} не поддерживается, так как не является целочисленным (int).
DoWhileRequiresCondition=Перед использованием действия DoWhile "{0}" необходимо задать условие.
DUActivityTypeMismatch=Это действие в обновленном определении имеет тип "{0}", а в исходном определении - тип "{1}".
DUActivityTypeMismatchRuntime=Тип действия изменяется в процессе обновления.
DUDisallowIfCannotFindingMatchingCondition=StateMachine не поддерживает динамическое обновление, если триггер условного перехода удален, или действие Condition в обновленном определении переназначено из другого свойства.
DuplexContractsNotSupported=Рабочий процесс не поддерживает контракты Duplex. Удалите свойство CallbackContract из атрибута ServiceContractAttribute. 
DuplicateAnnotationName=Не удалось добавить заметку с именем "{0}". Проверьте запросы профиля отслеживания на повторяющиеся имена в заметках или переменных среды. 
DuplicateCatchClause=Для типа {0} уже существует предложение catch. Для каждого уникального типа исключения CLR может быть добавлено только одно предложение catch.
DuplicateCorrelationQuery=Обнаружен дубликат запроса CorrelationQuery с параметром Where="{0}". Это дубликат не будет использоваться при расчете корреляции.
DuplicatedContract=Несколько реализованных типов контрактов содержат контракт "{0}" и операцию "{1}".
DuplicateDefinitionIdentity=WorkflowService с ({0}) DefinitionIdentity уже существует.
DuplicateEvaluationOrderValues=Действие "{0}" имеет несколько аргументов среды выполнения, для которых порядок оценки имеет значение "{1}". Значения порядка оценки аргументов среды выполнения должны быть уникальными.
DuplicateImportAttribute=Свойство "{0}" операции DynamicActivity "{1}" имеет более одного атрибута ImportAttribute. Для одного свойства разрешается указывать только один атрибут ImportAttribute.
DuplicateInstanceKeyExists=Значение ключа экземпляра "{0}" уже существует. Это могло произойти из-за того, что определено несколько наборов MessageQuerySets, вычисляющих один и тот же CorrelationKey.
DuplicateInstrumentation=Дублировать инструментарий для {0}.  Возможно прерывание выполнения отладчиком в неверном местоположении.
DuplicateMethodFound=Неоднозначное совпадение. Действие "{0}" имеет несколько открытых методов "{1}" с именем "{2}" и совпадающими типами параметров, аргументов универсального типа и ограничений общего типа, передаваемыми в метод InvokeMethod "{3}".
DuplicateOriginActivityActivity=Объект того же происхождения "{0}" используется действиями "{1}" и "{2}".
DuplicateOriginActivityVariable=Объект того же происхождения "{0}" используется действием "{1}" и переменной "{2}".
DuplicateOriginVariableVariable=Объект того же происхождения "{0}" используется переменными "{1}" и "{2}".
DurationIsNegative=Значение аргумента Duration в действии Delay "{0}" отрицательно.
DUTriggerOrConditionChangedDuringTransitioning=StateMachine не поддерживает динамическое обновление, если состояние меняется, а текущий переход был изменен.
DynamicActivityDuplicatePropertyDetected=Свойство с именем "{0}" уже существует в коллекции DynamicActivity.Properties.
DynamicActivityMultipleExpressionLanguages=Указанное определение действия содержит несколько языков действий выражений, требующих компиляции (обнаружено языков: "{0}"). Для одного определения разрешено указывать только один язык, требующий компиляции. Преобразуйте все действия выражений, требующие компиляции, в один язык.
EmptyCorrelationQueryResults=Запрос корреляции выдал пустой результирующий набор. Убедитесь, что запросы корреляции для конечной точки настроены правильно.
EmptyGuidOnDeserializedInstance=Идентификатор десериализованного экземпляра состоит только из нулей (Guid.Empty). Сериализованный экземпляр должен иметь ненулевой идентификатор.
EmptyIdReturnedFromHost=Реализация свойства "Id" узла потока операций типа "{0}" возвратила нулевой идентификатор. Реализация WorkflowInstance должна возвращать идентификатор экземпляра, отличный от Guid.Empty.
EndpointAddressNotSetInEndpoint=Не удалось получить EndpointAddress из конечной точки, файла конфигурации и контекста обратного вызова. Это могло произойти из-за того, что ни в конечной точке, ни в ее конфигурации не задано действие с OperationName="{0}".
EndpointIncorrectlySet=Свойства Endpoint и EndpointConfigurationName задаются в действии "{0}" при помощи параметра OperationName="{1}". За один раз можно задать только одно из них.
EndpointNotSet=Действие "{0}" с параметром OperationName="{1}" должно задавать или конечную точку, или свойство EndpointConfigurationName.
EndSqlCommandExecute=Окончание выполнения команды SQL: {0}
EnlistedTransactionPropertiesRequireIsolationBlocks=Свойство TransactionProperty с параметром enlistWorkflowState, имеющим значение true, должно быть добавлено в блок изоляции.
EnterNoPersistBlock=Выполняется вход в непостоянный блок.
EnumeratorNotStarted=Перечисление не запущено. Вызовите метод MoveNext.
EnvironmentDisposed=Объект LocationEnvironment доступен только из области условия, в которое он был передан.
ErrorExtractingValuesForLambdaRewrite=При попытки извлечения целевого объекта типа "{0}" из выражения вызова метода "{1}" произошла ошибка.  Учтите, что выражение, которое определяет объект типа "{0}", не должно требовать контекст времени выполнения.  Ошибка: {2}
ErrorsEncounteredWhileProcessingTree=При обработке дерева рабочих процессов произошли следующие ошибки:
ErrorTimeToPersistLessThanZero=Значение TimeToPersist должно быть больше или равно TimeSpan.Zero. Для отключения присвойте значение, равное TimeSpan.MaxValue.
ErrorTimeToUnloadLessThanZero=Значение TimeToUnload должно быть больше или равно TimeSpan.Zero. Для отключения присвойте значение, равное TimeSpan.MaxValue.
EtwAPIMaxStringCountExceeded=Количество строковых аргументов, переданных в Etw WriteEvent, превысило максимальный допустимый предел {0}.
EtwMaxNumberArgumentsExceeded=Количество аргументов, переданных в Etw WriteEvent, превысило максимальный допустимый предел {0}.
EtwRegistrationFailed=Ошибка регистрации ETW с кодом ошибки {0}.
EtwUnhandledException=Необработанное исключение. Сведения об исключении: {0}
ExclusiveHandleRegisterBookmarkScopeFailed=Метод RegisterBookmarkScope может быть вызван, только если нет закладок в области соответствующего класса ExclusiveHandle.
ExclusiveHandleReinitializeFailed=Повторная инициализация может быть произведена только при отсутствии закладок, зарегистрированных в классе ExclusiveHandle.
ExecuteMustBeNested=Недопустимая реализация InstanceStore в поставщике сохраняемости. Она пытается одновременно выполнить несколько вложенных команд. Для каждого вызова InstanceStore.TryCommand (или BeginTryCommand) в каждый момент времени разрешается только один вызов метода InstancePersistenceContext.Execute (или BeginExecute). Эта ошибка указывает на недопустимую реализацию поставщика сохраняемости.
ExecuteWorkItemStart=Запуск выполнения рабочего элемента
ExecuteWorkItemStop=Остановка выполнения рабочего элемента
ExecutionPropertyAlreadyDefined=Свойство с именем "{0}" уже было определено в этой области. Чтобы заменить текущее свойство, сначала удалите его, а затем добавьте новое.
ExitNoPersistBlock=Выполняется выход из непостоянного блока.
ExpressionRequiredForConversion=Для преобразования требуется выражение.
ExtensionsCannotBeModified=WorkflowInstanceExtensionsManager нельзя изменять, если он был связан с WorkflowInstance.
ExtensionsCannotBeSetByIndex=Коллекция расширений не поддерживает установку расширений по индексу. Используйте методы Add и Remove.
ExtensionTypeNotSupported=Добавление расширения типа "{0}" не поддерживается WorkflowServiceHost.
ExternalLocationsGetOnly=Расположение, которое вы пытаетесь задать, относится к классу SymbolResolver. Расположения класса SymbolResolver предназначены только для чтения.
ExtraOverloadGroupPropertiesConfigured=Перегруженная группа"{0}" уже настроена. Настройка свойства "{1}" в перегруженной группе "{2}" является ошибкой.
ExtraParameter=Параметр "{0}" не объявлен в операции "{1}" контракта "{2}".
ExtraReturnValue=Действие содержит возвращаемое сообщение, а контракт не содержит возвращаемого значения.
FailedToCreateSecurityToken=Не удалось создать токен безопасности "{0}".
FailedToGetInstanceIdForControlOperation=Не удалось получить идентификатор экземпляра из сообщения для этой операции управления. Это может быть вызвано несовпадением контракта. Убедитесь в том, что контракт клиента совпадает с контрактом конечной точки службы.
FailedToGetWorkflowIdentityForControlOperation=Не удалось получить WorkflowIdentity из сообщения для этой операции управления. Это может быть вызвано несовпадением контрактов. Убедитесь в том, что контракт клиента совпадает с контрактом конечной точки службы.
FailedToInitializeRequestReplyCorrelationHandle=В действии Receive, настроенном с операцией запроса-ответа "{0}", не удалось инициализировать дескриптор RequestReplyCorrelation. В свойстве CorrelationMessageProperty полученного сообщения должен содержаться ключ InstanceKey со значением RequestReplyCorrelation.
FailedToLoadBindingInControlEndpoint=Не удалось загрузить привязку "{0}" с конфигурацией "{1}" для стандартной конечной точки управления "{2}".
FailFastMessage=Произошла неустранимая ошибка. В целях диагностики приводится сообщение на английском языке, связанное с ошибкой: "{0}".
FaultContextNotFound=При повторном создании исключения действию "{0}" не удается найти класс FaultContext, заданный в действии TryCatch. Чтобы решить данную проблему, не изменяйте и не удаляйте класс FaultContext из коллекции свойств исполнения.
FaultTypeMismatch=Указанный тип ошибки "{0}" не существует для операции "{1}" в контракте "{2}".
FinalStateCannotHaveProperty=Конечное состояние "{0}" не должно содержать действие {1}.
FinalStateCannotHaveTransition=Конечное состояние "{0}" не должно содержать никаких исходящих транзиций.
FirstParameterDoesnotMatchTheReturnValue=Первый параметр типа "{0}", указанный в содержимом, не соответствует типу "{1}", указанному для возвращаемого значения операции "{2}" в контракте "{3}".
FlowchartContainsReferences=Блок-схема не поддерживает динамическое обновление, если она содержит ссылки на импортированных потомков.
FlowchartContainsUnconnectedNodes=Прежде чем можно будет использовать блок-схему "{0}", все узлы должны быть подключены, если для ValidateUnconnectedNodes установлено значение True.
FlowchartEmpty=Блок-схема "{0}" была выполнена без узлов.
FlowchartMissingStartNode=Блок-схема "{0}" не имеет начального узла (StartNode).
FlowchartNextNull=Блок-схема "{0}"/FlowStep: узел Next имеет значение null. Выполнение блок-схемы будет завершено.
FlowchartStart=Блок-схема "{0}": запуск запланирован.
FlowchartSwitchCase=Блок-схема "{0}"/FlowSwitch: выбрано действие Case "{1}".
FlowchartSwitchCaseNotFound=Блок-схема "{0}"/FlowSwitch: не удалось найти ни действие Case, ни действие Default Case, соответствующее результату выражения Expression. Выполнение блок-схемы будет завершено.
FlowchartSwitchDefault=Блок-схема "{0}"/FlowSwitch: выбрано действие Default Case.
FlowDecisionRequiresCondition=Перед использованием действия FlowDecision в блок-схеме "{0}" необходимо задать условие.
FlowedTransactionDifferentFromAmbient=Поточная транзакция отличается от внешней транзакции.
FlowNodeCannotBeShared=Узел FlowNode не может использоваться совместно разными блок-схемами. Он уже используется в блок-схеме "{0}" и не может использоваться в блок-схеме "{1}".
FlowNodeLockedForRuntime=Узел FlowNode в блок-схеме"{0}" уже открыт и не может быть изменен. Узел FlowNode можно изменять только во время разработки.
FlowSwitchRequiresExpression=Перед использованием переключателя FlowSwitch в блок-схеме "{0}" необходимо задать выражение.
ForEachRequiresNonNullValues=Перед использованием действия ForEach "{0}" необходимо привязать значения к непустому выражению.
FoundProcessingError=Не удалось выполнить команду: {0}
GeneratedAndProvidedMapConflict=В этом действии имеются конфликтующие изменения. Изменения произведены картой реализации и текущим обновлением. Действие совершило попытку сохранить исходные значения в обе карты.
GeneratedAndProvidedMapConflictRuntime=В этом действии имеются конфликтующие изменения. Изменения произведены обновлением реализации и обновлением более крупного рабочего процесса. Действие совершило попытку сохранить исходные значения в оба обновления.
GenericInstanceCommand=Выполнение InstancePersistenceCommand с именем {0} прервано из-за ошибки.
GenericInstanceCommandNull=Выполнение InstancePersistenceCommand прервано из-за ошибки.
GetLocationOnPublicAccessReference=Действию "{0}" не удается вызвать метод GetLocation для этой ссылки на открытое местоположение, так как она была создана методом CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation. Чтобы прочитать или записать значение, используйте методы ActivityContext.GetValue или SetValue. Чтобы получить прямой доступ к местоположению, объявите его с помощью метода CodeActivityPublicEnvironmentAccessor.TryGetReferenceToPublicLocation.
GetParameterTypeMismatch=Параметр по индексу {0} был запрошен в InstancePersistenceAction с именем {1} с использованием неверного аргумента универсального типа. При вызове метода GetParameter<T> тип, указанный в аргументе T, должен соответствовать типу параметра в документации.
GetRunnableRequiresOwner=Перед вызовом этого метода укажите поддерживаемые идентификаторы определения для этого узла рабочего процесса, вызвав метод WorkflowApplication.CreateDefaultInstanceOwner.
GuidCannotBeEmpty=Аргумент должен быть ненулевым идентификатором GUID.
HandledException=Обработка исключения. Сведения об исключении: {0}
HandledExceptionError=Обработка исключения. Сведения об исключении: {0}
HandledExceptionVerbose=Обработка исключения. Сведения об исключении: {0}
HandledExceptionWarning=Обработка исключения. Сведения об исключении: {0}
HandleFreed=Выполнение команд InstancePersistenceCommands было отменено, поскольку дескриптор InstanceHandle был освобожден.
HandleFreedBeforeInitialized=Метод Free нельзя вызывать для дескриптора InstanceHandle во время выполнения для этого дескриптора метода OnNewInstanceHandle.
HandleFreedInDirectory=Выполнение команд InstancePersistenceCommand отменено, поскольку освобожден дескриптор InstanceHandle.
HandleInitializationContextDisposed=К контексту HandleInitializationContext можно обратиться только из области функции, в которую он был передан.
HandleNotInitialized=Дескриптор не инициализирован.  Дескрипторы должны создаваться и инициализироваться средой выполнения, и являются допустимыми только в той области, в которой они объявлены.
HasExecutingChildrenNoPersist=Несохраняемые блоки могут быть настроены только когда нет выполняемых дочерних действий.
HostIdDoesNotMatchInstance=Идентификатор экземпляра, переданный узлом потока операций, {0}, не совпадает с идентификатором, хранящимся в сериализованном экземпляре, {1}. Компьютер не может десериализовать экземпляр с идентификатором, отличным от идентификатора, использованного при его сериализации.
HostLockExpired=Срок действия блокировки SqlWorkflowInstanceStore истек. Это могло произойти из-за того, что SQL Server занят или соединение временно потеряно.
HostLockNotFound=Блокировка SqlWorkflowInstanceStore не существует в базе данных. Это могло произойти из-за того, что SQL Server занят или соединение временно потеряно.
IdentityControlCharacter=WorkflowIdentity.Name и пакет не могут содержать управляющие символы (символы Юникода категории Cc).
IdentityNameSemicolon=WorkflowIdentity.Name не может содержать символ точки с запятой ";".
IdentityNotSupportedWithActivation=SqlWorkflowInstanceStore не поддерживает активацию для InstanceOwners, которые указывают DefinitionIdentities.
IdentityWhitespace=WorkflowIdentity.Name и Package не могут содержать начальные или конечные пробелы (категории символов Юникода Zl, Zp или Zs).
IdNotFoundInWorkflow=Не удается найти в рабочем процессе указанный идентификатор "{0}". Проверьте рабочий процесс на наличие ошибок проверки подлинности, способные создавать поддеревья, которые нельзя просмотреть.
ImplementationVersionMismatch=Параметр ImplementationVersion ("{0}") загруженного экземпляра действия не соответствует параметру ImplementationVersion ("{1}") указанного действия ("{2}"). Экземпляр можно обновить путем применения карты реализации.
InArgumentBound=В аргументе "{0}" элемента Activity "{1}", DisplayName: "{2}", InstanceId: объект "{3}" был связан со следующим значением: {4}.
IncompatibleArgumentType=Этому методу передан аргумент неверного типа. Для этого метода ожидается аргумент типа {0}, однако ему передан аргумент типа {1}.
IncompatibleTypeForMultidimensionalArrayItemReference=Универсальный тип "{0}" несовместим с типом действительного элемента "{1}" операнда Array в MultidimensionalArrayItemReference.
IncorrectIndexForArgument=Неправильный индекс для возвращаемого аргумента в коллекции "{0}". Задана позиция "{1}", тогда как ожидалась позиция "{2}".
IncorrectValueType=Из хранилища экземпляров извлечено значение неверного типа.  Ожидалось значение типа {0}, вместо него обнаружено значение типа {1}.
IndexOutOfBounds=Значение индекса ({0}) равно или больше длины массива ({1}).
IndicesAreNeeded=Для {0} действия "{1}" необходимо задать хотя бы одно значение индекса.
InferredContractDescription=Описание ContractDescription с параметрами Name="{0}" и Namespace="{1}" было выведено из WorkflowService.
InferredOperationDescription=Описание OperationDescription с параметром Name="{0}" в контракте "{1}" было выведено из WorkflowService. IsOneWay={2}.
InitializationIncomplete=Инициализация экземпляра действия не завершена.  Эта ошибка возникает при сбое выражения по умолчанию для переменной или выражения аргумента, и обработчик исключений позволяет продолжить выполнение.
InitializeCorrelationRequiresWorkflowServiceHost=Действие "{0}" необходимо использовать в узле службы WorkflowServiceHost.
InitialMetadataCannotBeDeleted=Значение сохраняемости с именем {0} указывается в качестве исходного значения метаданных и поэтому должно иметь допустимое InstanceValue, отличное от InstanceValue.DeletedValue.
InitialStateCannotBeFinalState=Начальное состояние "{0}" не должно также быть конечным.
InitialStateNotInStatesCollection=Исходное состояние "{0}" должно быть добавлено в коллекцию States конечного автомата.
InlinedLocationReferenceOnlyAccessibleByOwner=Действие "{0}" не имеет доступа к этой ссылке на открытое расположение, поскольку она допустима только для действия "{1}". Ссылку на открытое расположение может использовать только действие, получившее ее.
InputParametersCountMismatch=Количество переданных входных параметров {0} не соответствует ожидаемому количеству {1}.
InputParametersMissing=Ожидаемый входной параметр с именем "{0}" не обнаружен.
InputParametersTypeMismatch=Для параметра с именем "{1}" ожидалось значение входного параметра типа "{0}".
InstanceCollisionDefault=Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр уже был сохранен в хранилище экземпляров.
InstanceCollisionSpecific=Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр "{0}" уже был сохранен в хранилище экземпляров.
InstanceCompleteDefault=Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр уже выполнен.
InstanceCompleteSpecific=Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр "{0}" уже выполнен.
InstanceHandleConflictDefault=Выполнение InstancePersistenceCommand прервано, поскольку другой допустимый InstanceHandle удерживает блокировку экземпляра, что указывает на то, что уже загружена неустаревшая копия экземпляра. Следует использовать загруженную копию экземпляра и связанный с ней InstanceHandle либо выгрузить ее.
InstanceHandleConflictSpecific=Выполнение InstancePersistenceCommand прервано, поскольку другой допустимый InstanceHandle удерживает блокировку экземпляра "{0}", что указывает на то, что уже загружена неустаревшая копия экземпляра. Следует использовать загруженную копию экземпляра и связанный с ней InstanceHandle либо выгрузить ее.
InstanceKeyMetadataChangesNotSupported=SqlWorkflowInstanceStore не поддерживает изменение метаданных для уже существующих ключей.
InstanceKeyRequiresValidGuid=Ключ InstanceKey нельзя создать со значением, состоящим только из нулей, например Guid.Empty. Чтобы получить InstanceKey, состоящий только из нулей, используйте InstanceKey.InvalidKey.
InstanceLockedUnderTransaction=Не удалось выполнить операцию управления "{0}" над экземпляром службы с идентификатором "{1}". В настоящее время выполняется активная операция транзакционного контроля.
InstanceLockLostDefault=Выполнение InstancePersistenceCommand, прервано из-за разблокирования экземпляра. Эта ошибка означает, что копия экземпляра, находящаяся в памяти, устарела и ее необходимо удалить вместе с InstanceHandle.
InstanceLockLostSpecific=Выполнение InstancePersistenceCommand, прервано из-за разблокирования экземпляра "{0}". Эта ошибка означает, что копия экземпляра, находящаяся в памяти, устарела и ее необходимо удалить вместе с InstanceHandle.
InstanceLocksRecoveryError=Не удалось восстановить блокировки экземпляров, поскольку обнаружено следующее исключение
InstanceMethodCallRequiresTargetObject=Для вызова метода экземпляра требуется целевой объект.
InstanceMustBePaused=Для выполнения этой операции экземпляр должен быть приостановлен.
InstanceMustNotBePaused=Для выполнения этой операции экземпляр не должен быть приостановлен.
InstanceMustNotBeSuspended=Эту операцию невозможно выполнить, поскольку экземпляр приостановлен.
InstanceNotReadyDefault=Выполнение InstancePersistenceCommand прервано, поскольку экземпляр еще не сохранен в хранилище экземпляров.
InstanceNotReadySpecific=Выполнение InstancePersistenceCommand прервано, поскольку экземпляр "{0}" еще не сохранен в хранилище экземпляров.
InstanceOperationRequiresInstance=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой требуется экземпляр, однако к операции не привязан экземпляр.
InstanceOperationRequiresLock=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой требуется удерживать блокировку экземпляра, однако блокировка не удерживается.
InstanceOperationRequiresNotCompleted=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой экземпляр должен иметь состояние, отличное от InstanceState.Completed, но экземпляр находится именно в этом состоянии.
InstanceOperationRequiresNotUninitialized=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой экземпляр должен иметь состояние, отличное от InstanceState.Uninitialized, но экземпляр находится именно в этом состоянии.
InstanceOperationRequiresOwner=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой требуется владелец экземпляра, однако к операции не привязан владелец.
InstanceOwnerDefault=Выполнение InstancePersistenceCommand прервано, поскольку регистрация владельца экземпляра стала недействительной. Эта ошибка означает, что находящиеся в памяти копии всех экземпляров, заблокированных данным владельцем, устарели и их необходимо удалить вместе с дескрипторами InstanceHandle. Для устранения этой ошибки обычно лучше всего перезагрузить узел.
InstanceOwnerSpecific=Выполнение InstancePersistenceCommand прервано, поскольку регистрация владельца экземпляра с идентификатором "{0}" стала недействительной. Эта ошибка означает, что находящиеся в памяти копии всех экземпляров, заблокированных данным владельцем, устарели и их необходимо удалить вместе с дескрипторами InstanceHandle. Для устранения этой ошибки обычно лучше всего перезагрузить узел.
InstanceRequired=Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand. Для этой команды требуется экземпляр, однако к дескриптору InstanceHandle не привязан экземпляр.
InstanceStoreBoundSameVersionTwice=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она дважды сообщила о получении и фиксации одной версии блокировки для одного экземпляра. Каждый раз, когда для экземпляра получается блокировка, версия блокировки должна увеличиваться. В противном случае в качестве версии блокировки всегда следует возвращать значение 0. Если поставщик обнаруживает, что владелец экземпляра пытается заблокировать уже заблокированный экземпляр, то поставщик должен вызвать метод BindReclaimedLock, BeginBindReclaimedLock или CreateBeginBindReclaimedLockException вместо метода BindAcquiredLock.
InstanceStoreDoesntMatchWorkflowApplication=Экземпляр настроен с InstanceStore, который отличается от этого WorkflowApplication.
InstanceStoreFailed=Реализация InstanceStore создало исключение InstancePersistenceException. Исключение InstancePersistenceException является внутренним исключением.
InstanceStoreHasDefaultOwner=Это InstanceStore уже имеет DefaultInstanceOwner.
InstanceStoreReadOnly=SqlWorkflowInstanceStore доступен только для чтения, дальнейшая настройка невозможна. Конфигурация SqlWorkflowInstanceStore должна быть полностью завершена до создания первого InstanceHandle.
InstanceStoreRequiredToPersist=Только приложения WorkflowApplications, которые были настроены с помощью InstanceStore, могут быть сохранены или выгружены.
InstanceSuspended=Экземпляр службы с идентификатором "{1}" находится в настоящий момент в состоянии "Suspended". Не удалось выполнить операцию управления "{0}".
InsufficientArraySize=Размер массива равен {0}, и этого недостаточно для хранения результатов операции.
InternalCacheMetadataStart=InternalCacheMetadata запущено для действия "{0}".
InternalCacheMetadataStop=InternalCacheMetadata остановлено для действия "{0}".
InternalConstraintException=Во внутреннем ограничении возникло исключение при применении ограничения с именем "{0}" к действию типа {1} с именем "{2}".  Исключением было: {3}
InternalServerError=Серверу не удалось обработать запрос из-за внутренней ошибки.  Для получения дополнительных сведений об ошибке либо включите на сервере параметр IncludeExceptionDetailInFaults (или в атрибуте ServiceBehaviorAttribute, или в поведении конфигурации <serviceDebug>), чтобы отправить сведения об исключении обратно клиенту, либо включите трассировку, как описано в документации к пакету SDK для платформы Microsoft .NET Framework 4.0, и изучите журналы трассировки на сервере.
InvalidActivityIdFormat=Переданный идентификатор действия имел недопустимый формат.  Он должен быть списком целочисленных значений, разделенных точками, например "1.12.3", без начальных и конечных точек.
InvalidActivityToBlockUpdate=Действие "{0}" в DynamicUpdateMapBuilder.DisallowUpdateInside не является открытым элементом DynamicUpdateMapBuilder.UpdatedWorkflowDefinition. Убедитесь, что это действие является элементом обновленного определения рабочего процесса. Если это действие было удалено как элемент обновления, не требуется явно блокировать обновление. Обновление автоматически блокируется, если удаленное действие запущено.
InvalidActivityToBlockUpdateServices=Действие "{0}" не является открытым элементом обновленного WorkflowDefinition. Убедитесь, что это действие является элементом обновленного определения рабочего процесса. Если это действие было удалено как элемент обновления, не требуется явно блокировать обновление. Обновление автоматически блокируется, если удаленное действие запущено.
InvalidArgumentExpression=Выражение аргумента номер {0} типа "{1}" недопустимо.
InvalidAsyncBeginMethodSignature=Недопустимая сигнатура асинхронного метода Begin для метода {0} в типе {1}. Метод Begin должен принимать параметр AsyncCallback и объект, в качестве двух последних аргументов, и возвращать параметр IAsyncResult.
InvalidAsyncCancelMethodSignature=Недопустимая сигнатура асинхронного метода Cancel для метода {0} в типе {1}. Метод Cancel не должен принимать аргументы и возвращать значения типа void.
InvalidAsyncEndMethodSignature=Недопустимая сигнатура асинхронного метода End для метода {0} в типе {1}. Метод End должен принимать в качестве последнего аргумента параметр IAsyncResult. 
InvalidAsyncResult=Методу "End" передан неверный результат IAsyncResult. Объект IAsyncResult, передаваемый методу "End", должен возвращаться из соответствующего метода "Begin" или передаваться в обратный вызов, указанный для "Begin".
InvalidAsyncResultImplementation=Неверная реализация интерфейса IAsyncResult может возвращать неверные значения свойства CompletedSynchronously или несколько раз вызывать AsyncCallback. Возможно, тип {0} реализован неверно.
InvalidAsyncResultImplementationGeneric=Неверная реализация интерфейса IAsyncResult может возвращать неверные значения свойства CompletedSynchronously или несколько раз вызывать AsyncCallback.
InvalidCallbackState=Объекту состояния обратного вызова должны быть переданы допустимые данные {0}.
InvalidCompensateActivityUsage=Действие компенсации "{0}" с незаданным входным аргументом InArgument "Target" можно использовать только в контексте обработчика компенсации, подтверждения или отмены.
InvalidCompensationToken=Переменная, связываемая с InArgument "Target", имеет значение NULL. InArgument "Target" необходимо задавать с помощью допустимого CompensationToken, полученного из CompensableActivity. В противном случае, если требуется использовать Compensation или Confirmation, не задавайте "Target" InArgument и не используйте действие "{0}" в контексте обработчика компенсации, подтверждения или отмены.
InvalidConfirmActivityUsage=Действие подтверждения "{0}" с unset "Target" InArgument можно использовать только в контексте обработчика компенсации, подтверждения или отмены.
InvalidDataFromReceiveBookmarkState=Не удалось получить допустимый контекст MessageContext при возобновлении вкладки для операции получения "{0}".
InvalidDataFromSendBookmarkState=Не удалось получить допустимое свойство CorrelationMessageProperty при возобновлении вкладки для операции отправки "{0}".
InvalidDirectionForArgument=Для аргумента в коллекции "{0}" в позиции {1} указано неправильное направление. Указано направление "{2}", ожидалось направление "{3}".
InvalidDynamicActivityProperty=Недопустимый дескриптор свойства. Указанный компонент не содержит свойство, соответствующее этому дескриптору ({0}).
InvalidEvaluationOrderValue=Недопустимое значение EvaluationOrder. Значения порядка оценки должны начинаться с нуля, возрастать и быть уникальными. Для обозначения того, что порядок оценки не задан, используйте значение "-1".
InvalidExecutionCallback="{0}" является недопустимым обратным вызовом выполнения действия. Обратный вызов, используемый "{1}", должен быть методом экземпляра в "{1}".
InvalidExpressionForLocation=Расположение нельзя создать из выражения типа "{0}".
InvalidExpressionProperty=Свойство "Expression" типа "{0}" является недопустимым.
InvalidFileName=Для действия {0} было указано недопустимое имя файла
InvalidGenericTypeInfo=Тип "{0}" содержит некоторые недопустимые данные универсального типа.
InvalidIdleAction=Возвращенное значение PersistableIdleAction выходит за границы диапазона.  Оно должно иметь значение None, Unload или Persist.
InvalidImplementationAsWorkflowRoot=Чтобы карта реализации была непосредственно применена к экземпляру рабочего процесса, корень ее определения не должен иметь открытых/импортированных потомков или открытых/импортированных делегатов.
InvalidImplementationAsWorkflowRootForRuntimeState=Чтобы карта реализации была непосредственно применена к экземпляру рабочего процесса, корень ее определения не должен иметь открытых/импортированных потомков. Экземпляр имеет один или несколько запущенных в настоящее время открытых потомков.
InvalidImplementationAsWorkflowRootForRuntimeStateBecauseArgumentsChanged=Чтобы карта реализации была непосредственно применена к экземпляру рабочего процесса, она должна показывать, что изменений аргументов не производилось. Карта реализации показывает, что аргументы определения действия были изменены.
InvalidImplementationMap=Указанная карта реализации не соответствует определению действия. Убедитесь, что версия действия, на которое ссылается обновленный рабочий процесс, совпадает с версией, указанной в карте реализации.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: число элементов в карте: "{0}"; число элементов в определении: "{1}".
InvalidImplementationMapAssociation=Карта реализации, указанная для действия "{0}" с помощью DynamicUpdateMapBuilder.LookupImplementationMap, не может быть использована, так как действие не имеет потомков реализации. Убедитесь, что метод SetImplementationMap был вызван для нужного действия.
InvalidImplementationMapAssociationServices=Карта реализации, указанная для действия "{0}" с помощью DynamicUpdateServices.SetImplementationMap, не может быть использована, так как действие не имеет потомков реализации. Убедитесь, что метод SetImplementationMap был вызван для нужного действия.
InvalidImplementationMapRuntime=При построении карты обновления для этого действия была указана неправильная карта реализации.
InvalidInstanceId=Для загрузки экземпляра использован недопустимый идентификатор экземпляра, состоящий только из нулей (Guid.Empty).
InvalidInstanceState=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке экземпляра с недопустимым значением InstanceState.
InvalidKey=Для загрузки или создания экземпляра использован недопустимый ключ.
InvalidKeyArgument=В качестве аргумента был передан недопустимый ключ, состоящий из одних нулей, например Guid.Empty.
InvalidLocationExpression=Недопустимое выражение расположения: отсутствуют скобки "[...]5D;".
InvalidLockRenewalPeriod=Предоставленный период обновления блокировки {0} меньше, чем минимальный период обновления блокировки {1}.
InvalidLockToken=Объект instanceVersion, передаваемый в InstancePersistenceContext.BindAcquiredLock, должен иметь положительное значение, если в поставщике сохраняемости реализовано управление версиями блокировки, и нулевое значение - в противном случае.
InvalidLValueExpression=Недопустимое L-значение в выражении.
InvalidMergeMap=Карта на позиции "{0}" (с отсчетом от нуля) для идентификатора действия "{1}" не соответствует предшествующей карте (картам). Убедитесь, что все карты представляют последовательные обновления одного определения рабочего процесса.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: {2}.
InvalidMergeMapArgumentCount=Ожидаемое число исходных аргументов = "{0}", фактическое число = "{1}".
InvalidMergeMapArgumentsChanged=Непредвиденное изменение в аргументах (название, направление, тип или порядок).
InvalidMergeMapEnvironmentCount=Число ожидавшихся исходных аргументов = "{0}", число открытых переменных = "{1}", число закрытых переменных = "{2}". Число фактических исходных аргументов = "{3}", число открытых переменных = "{4}", число закрытых переменных = "{5}".
InvalidMergeMapForImplementation=Ожидаемый ForImplementation = "{0}", фактический = "{1}".
InvalidMergeMapMemberCount=Ожидаемое число исходных элементов = "{0}", фактическое = "{1}".
InvalidMetadataValue=Указанное значение для свойства метаданных "{0}" должен принадлежать к типу {1}.
InvalidNullAsyncResult=Значение null возвращено из асинхронного метода "Begin" или передано в AsyncCallback. Асинхронные реализации "Begin" должны возвращать объект IAsyncResult, отличный от null, и передавать его в качестве параметра AsyncCallback.
InvalidOriginalWorkflowDefinitionForImplementationMapCreation=Предоставленное построителю карты определение OriginalWorkflowDefinition недопустимо для создания карты реализации, так как оно не имеет потомков реализации.
InvalidParameterInfo=Данные числового параметра ({0}) недопустимы в типе "{1}".
InvalidPrepareForRuntimeValidationSettings=Рабочий процесс не может быть подготовлен для выполнения, если любому из параметров SingleLevel, SkipValidatingRootConfiguration или OnlyUseAdditionalConstraints задано значение ValidationSettings.
InvalidProperty=Свойство ({0}) недопустимо или не определено.
InvalidPropertyType=Не удалось разрешить тип "{0}" свойства "{1}".
InvalidReceiveStateForDU=Операция Receive находится в состоянии, в котором обновление экземпляра не поддерживается. Обновление может быть выполнено, только если операция Receive ожидает сообщения с запросом на стороне сервера.
InvalidRootMergeMap=Карта на позиции "{0}" (с отсчетом от нуля) не соответствует предшествующей карте (картам). Убедитесь, что все карты представляют последовательные обновления одного определения рабочего процесса.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: {1}
InvalidRunnableInstancesDetectionPeriod=Указанный период обнаружения доступных для выполнения экземпляров {0} меньше минимального допустимого периода {1}.
InvalidRuntimeState=Указанное значение не является допустимым состоянием среды выполнения.
InvalidSemaphoreExit=Метод синхронизации объектов был вызван из несинхронизированного блока кода.
InvalidServiceImplementation=WorkflowServiceHost требует, чтобы объект serviceImplementation относился к Activity или WorkflowService.
InvalidSourceLocationColumn=Номер столбца должен быть больше 0 (1 разряд). Недопустимо: {0} = {1}.
InvalidSourceLocationLineNumber=Номер строки должен быть больше 0 (1 разряд). Недопустимо: {0} = {1}.
InvalidStateForAsyncCallback=Объект IAsyncResult, переданный в асинхронный обратный вызов, имеет недопустимое состояние AsyncState.
InvalidStateInAsyncResult=Указан недопустимый контекст состояния результата выполнения асинхронной операции.
InvalidTypeConverterUsage=Недопустимое использование класса TypeConverter.
InvalidTypeForArgument=Тип, указанный для аргумента в коллекции "{0}" в позиции {1}, не соответствует ожидаемому типу. Указан тип "{2}", ожидаемый тип: "{3}".
InvalidUnhandledExceptionAction=Значение возвращенного UnhandledExceptionAction выходит за пределы диапазона. Допустимы следующие значения: Abort, Cancel или Terminate.
InvalidUpdatedWorkflowDefinitionForImplementationMapCreation=Предоставленное построителю карты определение UpdatedWorkflowDefinition недопустимо для создания карты реализации, так как оно не имеет потомков реализации.
InvalidUpdateMap=Указанная карта не соответствует определению рабочего процесса. Убедитесь, что эта карта подходит для этого определения, а сериализованная карта не была изменена вручную.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: {0}
InvalidVisualBasicSettingsValue=Свойство Settings имеет недействительное значение. Задайте в качестве значения свойства Settings пустую строку или строку "Ссылки на сборки и импортированные пространства имен сериализованы в качестве пространств имен XML".
InvalidXamlMember=Идентификатор "{0}" недопустим в языке XAML.
InvokedMethodThrewException=Возникло исключение в методе, вызванном операцией "{0}". {1}
InvokeMethodDoesNotUseAsyncPattern=Метод InvokeMethod "{0}": в методе не используется асинхронная модель.
InvokeMethodIsNotStatic=Метод InvokeMethod "{0}": метод не является статическим.
InvokeMethodIsStatic=Метод InvokeMethod "{0}": метод является статическим.
InvokeMethodUseAsyncPattern=Метод InvokeMethod "{0}": в методе используется асинхронная модель "{1}" и "{2}".
IsolationLevelValidation=Значение объекта IsolationLevel вложенного действия TransactionScope должно быть равно значению его родителя.
ITextExpressionParameterMustBeActivity=параметр "выражение" должен иметь тип Activity.
KeyAlreadyAssociated=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о связывания ключа с экземпляром, с которым уже связан ключ.
KeyAlreadyCompleted=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о завершении уже завершенного ключа.
KeyAlreadyUnassociated=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила об отмене связи для ключа, который был связан с текущим экземпляром, но не был завершен.
KeyCollectionUpdatesNotAllowed=Изменение коллекции ключей, полученных из словаря, запрещено.
KeyCollisionDefault=Выполнение InstancePersistenceCommand прервано из-за конфликта ключей.
KeyCollisionSpecific=Выполнение команды InstancePersistenceCommand было прервано из-за конфликта ключей. Ключ экземпляра со значением "{1}" не может быть сопоставлен экземпляру "{0}", так как он уже сопоставлен другому экземпляру, "{2}".
KeyCollisionSpecificKeyOnly=Выполнение команды InstancePersistenceCommand было прервано из-за конфликта ключей. Ключ экземпляра со значением "{0}" не может быть сопоставлен экземпляру, так как он уже сопоставлен другому экземпляру.
KeyCompleteDefault=Выполнение команды InstancePersistenceCommand было прервано, так как ключ экземпляра уже завершен.
KeyCompleteSpecific=Выполнение команды InstancePersistenceCommand было прервано, так как ключ экземпляра "{0}" уже завершен.
KeyNotAssociated=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о завершении или изменении ключа, который не связан с текущим экземпляром.
KeyNotCompleted=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила об отмене связи для ключа, который еще не завершен.
KeyNotFoundInDictionary=Данный ключ отсутствует в словаре.
KeyNotReadyDefault=Выполнение InstancePersistenceCommand прервано, поскольку ключ экземпляра не связан с экземпляром. Возможно, экземпляр или ключ были очищены либо ключ является недопустимым. Ключ может быть недопустимым, если сообщение, из которого он создан, отправлено в неверное время или содержит неверные данные корреляции.
KeyNotReadySpecific=Выполнение InstancePersistenceCommand прервано, поскольку ключ экземпляра "{0}" не связан с экземпляром. Возможно, экземпляр или ключ были очищены либо ключ является недопустимым. Ключ может быть недопустимым, если сообщение, из которого он создан, отправлено в неверное время или содержит неверные данные корреляции.
LambdaExpressionReturnTypeInvalid=Лямбда-выражение не должно возвращать данные типа null или void.
LambdaExpressionTypeRequired=Приведенное выражение должно быть LambdaExpression.
LambdaNotXamlSerializable=Данный рабочий процесс содержит в коде лямбда-выражения. Эти выражения XAML-несериализуемы. Чтобы сделать рабочий процесс XAML-сериализуемым, используйте или VisualBasicValue/VisualBasicReference, или ExpressionServices.Convert(lambda). При этом лямбда-выражения будут преобразованы в действия выражений.
LegalCopyright=© Корпорация Майкрософт (Microsoft Corporation). Все права защищены.
LineNumberTooLarge=Указанный номер строки для действия {0} слишком велик и не поддерживается системой частичной проверки
LiteralsMustBeValueTypesOrImmutableTypes=Литерал поддерживает только типы значений и неизменяемый тип {0}.  Тип {1} не может использоваться в качестве литерала.
LoadedWriteOnlyValue=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке InstanceValue с заданным свойством InstanceValueOptions.WriteOnly. Значения, доступные только для записи, не должны загружаться.
LoadingAborted=Загрузка экземпляра прервана.
LoadingWorkflowApplicationRequiresInstanceStore=Для WorkflowApplication необходимо задать допустимый InstanceStore перед вызовом метода Load или LoadRunnableInstance.
LoadOpAssociateKeysCannotContainLookupKey=Если не указан LoadWorkflowByInstanceKeyCommand.AssociateLookupKeyToInstanceId, то необходимо заранее связать LookupInstanceKey с экземпляром. В противном случае команда LoadWorkflowByInstanceKeyCommand завершится ошибкой. Поэтому нельзя указывать LookupInstanceKey в коллекции InstanceKeysToAssociate, если не задан AssociateLookupKeyToInstanceId.
LoadOpFreeKeyRequiresAcceptUninitialized=Если указан LoadByKeyOperation.InstanceIdForFreeKey, свойство AcceptUninitializedInstance должен иметь значение true. Свободный ключ будет связан с неинициализированным экземпляром с заданным идентификатором.
LoadOpKeyMustBeValid=Ключ используется для поиска экземпляра, значения LoadByKeyOperation.LookupKey не должны быть равны нулю, например Guid.Empty.
LocationExpressionCouldNotBeResolved=Не удалось разрешить в переменную или свойство выражение расположения "{0}". Убедитесь, что выражение расположения можно разрешить в переменную или свойство, определенное в иерархии области.
LocationTypeMismatch=Не удается получить расположение с именем "{0}" как тип "{1}", поскольку оно имеет тип "{2}".  Необходимо точное соответствие типов, поскольку расположение предоставляет доступ и для чтения, и для записи.
LockRetryTimeout=Истекло время ожидания при получении блокировки экземпляра.  Не удалось выполнить операцию за выделенное время ожидания {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительное время ожидания.
LockTimeoutExceptionMessage=Не удалось объявить блокировку за выделенное время ожидания {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.
MapEntryNotFound=Сущности обновления карты для действия "{0}" не найдено.
MarkCanceledOnlyCallableIfCancelRequested=Метод MarkCanceled могут вызывать только действия, отмена которых запрошена. Перед вызовом этого метода проверьте ActivityInstance.HasCancelBeenRequested.
MaximumRetriesExceededForSqlCommand=Выполнено максимальное количество повторов команды SQL. Дальнейшие попытки выполняться не будут.
MaxInstancesExceeded=Система достигла предела, заданного для ограничителя "MaxConcurrentInstances". Для этого ограничителя был задан предел {0}. Значение ограничителя можно изменить, изменив атрибут "maxConcurrentInstances" в элементе serviceThrottle или изменив свойство "MaxConcurrentInstances" для поведения ServiceThrottlingBehavior.
MaxPendingMessagesPerChannelExceeded=Был достигнут предел регулирования "{0}" для "MaxPendingMessagesPerChannel". Для увеличения этого предела настройте свойство MaxPendingMessagesPerChannel для поведения BufferedReceiveServiceBehavior.
MaxPendingMessagesPerChannelMustBeGreaterThanZero=Предел глушителя должен быть больше нуля. Чтобы отключить, установите значение Int32.MaxValue.
MayBindLockCommandShouldValidateOwner=В команде InstancePersistenceCommand, которая возвращает значение true из AutomaticallyAcquiringLock, также должен переопределяться метод Validate, чтобы вызывать исключение InvalidOperationException, если команда выполняется с дескриптором InstanceHandle, который не привязан к InstanceOwner.
MemberCannotBeNull="{0}" в {1} действия "{2}" не может принимать значение null.
MemberIsReadOnly=Элемент "{0}" типа "{1}" доступен только для чтения. Он не может иметь тип LValue.
MemberNotFound=Член с именем "{0}" не найден в типе "{1}".
MemberNotSupportedByActivityXamlServices=ActivityXamlServices обнаружен элемент ({0}), который не поддерживается операцией DynamicActivity.
MessageCannotBeEmpty=Содержимое сообщения равно null, что не соответствует операции "{0}" в контракте "{1}".
MessageContentCannotHaveMoreThanOneParameter=Операция "{0}" согласно реализованному контракту "{1}" не может содержать более одного параметра для контракта сообщения.
MessageHeaderNotSupported=Пользовательские заголовки сообщений в MessageDescription не поддерживаются. Используйте тип данных с добавлением MessageContract в операции "{0}", контракт"{1}".
MessagePropertyIsNotSupported=Пользовательские свойства сообщений в MessageDescription не поддерживаются. Используйте тип данных с добавлением MessageContract в операции "{0}", контракт"{1}".
MessageTypeMismatch=Операция Receive указала тип System.ServiceModel.Channels.Message в ReceiveMessageContent, отличающийся от типа сообщения "{0}", указанного в операции "{1}" реализованного контракта "{2}".
MessageVersionInformationNotFound=Не удалось найти сведения о версии сообщения ответа.
MetadataCannotContainNullKey=В именованной коллекции (словаре) значений InstanceValue указано имя NULL. Значение NULL недопустимо в качестве имени InstanceValue.
MetadataCannotContainNullValue=В именованной коллекции (словаре) значений InstanceValue указано значение NULL. Для значения NULL указано имя {0}. Значение NULL недопустимо для InstanceValue. Чтобы указать значение NULL, используйте экземпляр InstanceValue с данными NULL, передав значение NULL в конструктор InstanceValue. Чтобы указать, что именованное значение нужно удалить, используйте InstanceValue.DeletedValue.
MethodInfoRequired=Требуется свойство Method типа "{0}".
MethodNameRequired=Требуется свойство Name типа "{0}".
MissingArgument=Аргумент с именем "{0}" имеет значение NULL в коллекции "{1}".
MissingBindingInEndpoint=У конечной точки с параметрами Name="{0}" и ServiceContract "{1}" отсутствует привязка. Укажите для этой конечной точки привязку.
MissingBodyInWorkflowService=Свойство Body текущего WorkflowService имеет значение NULL. Введите значение свойства Body для этой службы WorkflowService.
MissingDisplayNameInRootActivity=Корневое действие имеет пустое свойство DisplayName. Не устанавливайте свойство DisplayName корневого действия в значение NULL или пустую строку либо укажите Name для WorkflowService.
MissingKnownTypes=Известный тип "{0}" для операции "{1}" контракта "{2}" отсутствует.
MissingNameProperty=У аргумента типа "{0}" отсутствует имя. Для элементов в этой коллекции необходимо указывать свойство Name.
MissingOperationName=Свойство OperationName должно задаваться в действии "{0}".
MissingParameter=Коллекция параметров не содержит параметр "{0}", указанный для операции "{1}" в контракте "{2}".
MissingServiceContractName=Свойство ServiceContractName должно задаваться в действии "{0}" при помощи параметра OperationName="{1}".
MissingSetAccessorForIndexer=Свойство индексатора (Indexer) {0} для типа {1} не предоставляет метод присваивания значения (Setter).
MissingUriInEndpoint=Свойство Uri конечной точки с параметрами Name="{0}" и ServiceContract "{1}" имеет значение null или пусто. Для этой конечной точки должно быть задано свойство URI.
MisuseOfMessageContent=Контракт данных указан для операции "{0}" в контракте "{1}". Используйте ReceiveParameterContent для действия Receive и SendParameterContent для действия SendReply в соответствии с определением контракта.
MisuseOfParameterContent=Тип контракта сообщения указан для операции "{0}" в контракте "{1}". Используйте ReceiveMessageContent для действия Receive и SendMessageContent для действия SendReply в соответствии с определением контракта. 
MovingActivitiesInStateBlockDU=StateMachine не поддерживает динамическое обновление, если свойство действия в исходном определении переназначено другому свойству в элементе State или Transition.
MultiDimensionalArraysNotSupported=Многомерные массивы не поддерживаются.
MultipleFlowNodesSharingSameChildBlockDU=Блок-схема не поддерживает динамическое обновление, если несколько узлов FlowNode используют одно и то же дочернее действие.
MultipleLockOwnersNotSupported=SqlWorkflowInstanceStore не поддерживает одновременное создание нескольких владельцев блокировки. Рекомендуется установить параметр InstanceStore.DefaultInstanceOwner, чтобы совместно использовать хранилище большим числом приложений.
MultipleOverloadGroupsConfigured=Настроены следующие перегруженные группы: {0}. Аргументы можно задать только для одной перегруженной группы.
MustCallPrepareBeforeFinalize=Определение рабочего процесса не имеет присоединенной копии исходного определения. Перед обновлением рабочего процесса вызовите метод DynamicUpdateServices.PrepareForUpdate, чтобы сохранить копию исходного определения.
MustCancelOldTimer=Перед установкой нового необходимо отменить предыдущий таймер.
MustMatchReferenceExpressionReturnType=Ссылочные выражения не могут завершаться преобразованием. Тип указанного выражения должен в точности совпадать с типом T выражения VisualBasicReference<T> или LambdaReference<T>.
MustSetTransactionOnFirstCall=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Включающая транзакция (System.Transactions.Transaction.Current) задана в потоке, который вызывает InstancePersistenceContext.Execute или InstancePersistenceContext.BeginExecute, однако в этом эпизоде выполнения уже выполнены команды, для которых не заданы транзакции. Включающую транзакцию можно задать только для первого вызова Execute или BeginExecute (и только в случае, если для эпизода не заданы другие транзакции).
MustSpecifyConnectionStringOrName=Необходимо указать свойство connectionString или свойство connectionStringName.
NameCollisionOnCollect=Для имени "{0}", указанного участником сохраняемости типа "{1}", обнаружен конфликт имен. Значение, переданное реализацией CollectValues в участнике, использует одинаковое имя с другим значением, переданным этим или другим участником сохраняемости. Исправьте участник, чтобы в нем использовалось другое имя, не вызывающее конфликта, или удалите участник из коллекции расширений потока операций.
NameCollisionOnMap=Для имени "{0}", указанного участником сохраняемости типа "{1}", обнаружен конфликт имен. Значение, указанное реализацией MapValues в поставщике, использует одинаковое имя с другим значением, переданным этим или другим участником сохраняемости. Исправьте участник, чтобы в нем использовалось другое имя, не вызывающее конфликта, или удалите участник из коллекции расширений потока операций.
NativeActivityUpdateInstanceThrewException=Действие вызвало исключение из метода UpdateInstance: {0}
NAUCDisposed=Объект NativeActivityUpdateContext доступен только из области функции, в которую он был передан.
NewArrayBoundsRequiresIntegralArguments=В качестве аргументов методу NewArrayBounds необходимо передавать целочисленные значения.
NewArrayRequiresArrayTypeAsResultType=Типом результата действия "NewArray" должен быть конкретный тип массива.
NoAdditionalKeysOnInstanceIdLoad=Если в качестве поставщика сохраняемости используется InstanceStore, то при загрузке экземпляра по идентификатору нельзя указывать дополнительные ключи.
NoCAInSecondaryRoot=Действие CompensableActivity не может быть вложено в обработчик компенсации, подтверждения или отмены родителя CompensableActivity.
NoChangesMapQueryNotSupported=Запрос к карте NoChanges не поддерживается.
NoDynamicArgumentsInActivityDefinitionChange=В этом действии имеются конфликтующие изменения. Изменения произведены картой реализации и текущим обновлением. Аргументы действия изменены в обоих обновлениях.
NoDynamicArgumentsInActivityDefinitionChangeRuntime=В этом действии имеются конфликтующие изменения. Изменения произведены обновлением реализации и обновлением более крупного рабочего процесса. Аргументы действия изменены в обоих обновлениях.
NoNamespace=Не удается разрешить пространство имен "{0}:".
NonWASActivationNotSupported=SqlWorkflowInstanceStore поддерживает только активацию WAS.
NoOutputLocationWasFound=Аргумент {0} не соответствует допустимому расположению выходных данных.
NoOverloadGroupsAreConfigured=Для перегруженных групп заданы не все требуемые (допустимые) аргументы действия.
NoPersistScopeCannotContainPersist=Действие NoPersistScope "{0}" не может содержать действие Persist "{1}". 
NoPromotionsDefined=Именованное продвижение {0} не определяет никаких продвижений.
NoRunnableInstances=В InstanceStore не найдены доступные для выполнения экземпляры рабочего процесса, которые можно загрузить.
NoRuntimeTransactionExists=Вызов CompleteTransaction недопустим, если в среде выполнения нет активных транзакций.
NotSpecified=<не задано>
NotSupportMoreThanOneParametersInMessageContract=Операция не может содержать более одного параметра при использовании MessageContracts для операции "{0}" в контракте "{1}". Укажите допустимое определение контракта. 
NullAssignedToValueType=Из хранилища экземпляров извлечено значение неверного типа.  Ожидалось значение типа {0}, но вместо него обнаружено значение NULL.
NullCorrelationHandleInInitializeCorrelation=CorrelationHandle не может иметь значение null в "{0}".
NullCorrelationHandleInMultipleQueryCorrelation=По крайней мере в одном объекте QueryCorrelationInitializer не задан дескриптор корреляции. Дескриптор CorrelationHandle нужно задавать, если в коллекции CorrelationInitializers находится несколько элементов QueryCorrelationInitializer.
NullKeyAlreadyPresent=Элемент с ключом null уже был добавлен.
NullReferencedMemberAccess=Члену {1} не удалось разыменовать пустой объект типа {0}.
NullReplyMessageContractMismatch=От сервера получено ответное сообщение, равное null. Возможной причиной может быть несоответствие контрактов на сторонах клиента и сервера. Убедитесь, что рабочий процесс на стороне сервера настроен для двусторонней операции.
OnCancelRequestedThrew=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Обработчик события отмены вызвал исключения. Обработчик был определен методом InstancePersistenceContext.SetCancellationHandler.
OneOfTwoPropertiesMustBeSet=Для "{2}" в действии "{3}" обязательным является либо свойство "{0}", либо свойство "{1}".
OnewayContractIsImplementedAsTwoWay=Односторонняя операция "{0}" в контракте "{1}" не должна содержать действия SendReply. 
OnFreeInstanceHandleThrew=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Реализация метода OnFreeInstanceHandle вызвала исключение.
OnlyBookmarkOwnerCanRemove=Закладки может удалить только тот экземпляр действия, который создал их.
OnlyOneOperationPerActivity=Единовременно допускается выполнение одной операции для действия. В данный момент уже выполняется другая операция.
OnlyOneRequireTransactionContextAllowed=Среда выполнения пытается обработать вызов RequireTransactionContext.
OnlySingleCastDelegatesAllowed=Для событий WorkflowApplication допускаются только одноадресные делегаты.  Список вызова указанного делегата имеет длину больше одной строки.
OperationAlreadyCompleted=Операция уже завершена.
OperationDoesNotExistInContract=Операция "{0}" не существует в контракт с именем = "{1}" и пространством имен = "{2}".
OperationFormatterAndFaultFormatterIncorrectlySet=Параметры OperationFormatter и FaultFormatter не могут быть заданы одновременно.
OperationFormatterAndFaultFormatterNotSet=Параметры OperationFormatter и FaultFormatter не могут одновременно принимать значение null.
OperationHasSerializerBehavior=Для операции "{0}" в контракте "{1}" уже задано поведение "{2}", поэтому новое поведение добавить нельзя. Это обычно указывает на то, что метод IOperationSerializer.ApplyToOperation уже был вызван для данной операции.
OperationIsNotImplemented=Операция "{0}" контракта "{1}" не реализована в рабочем процессе.
OperationNotAvailable=Невозможно выполнить в данный момент операцию "{0}" над экземпляром службы с идентификатором "{1}". Убедитесь, что операции выполняются в правильном порядке, а используемая привязка гарантирует упорядоченную доставку.
OperationNotFound=Действие Receive по контракту {0} и операция {1} не найдены в WorkflowService по умолчанию. Убедитесь, что все операции в других версиях WorkflowService сначала были добавлены в WorkflowService по умолчанию.
OptionalExtensionTypeMatchedMultiple=Найдено несколько модулей типа "{0}". Не более одного расширения данного типа допустимо при запуске этого потока операций.
OriginalActivityReusedInModifiedDefinition=Действие "{0}" в исходном определении не может быть повторно использовано в обновленном определении.
OriginalVariableReusedInModifiedDefinition=Переменная "{0}" в исходном определении не может быть повторно использована в обновленном определении.
OriginCannotBeRuntimeIntrinsic=Объект "{0}" нельзя использовать в качестве исходного, так как он уже является элементом определения рабочего процесса (Activity, ActivityDelegate, Аргумент или LocationReference).
OutArgumentCannotHaveInputValue=OutArgument "{0}" не может быть задан с входным значением.  Ключ "{0}" необходимо удалить из словаря входных значений.
OutOfIdSpaceIds=Число действий в этом пространстве идентификаторов превысило значение Int32.MaxValue.  Выполните рефакторинг части рабочего процесса в новый подкласс действия.
OutOfInstanceIds=В рабочем процессе можно выполнить только long.MaxValue экземпляров элемента Activity.
OutOfInternalBookmarks=Для рабочего процесса можно создать только long.MaxValue внутренних закладок.
OutOfRangeSourceLocationEndColumn=Для одной строки SourceLocation должно выполняться неравенство: endColumn >= startColumn (= {0}).
OutOfRangeSourceLocationEndLine=Для расположения SourceLocation должно выполняться неравенство: endLine >= startLine (= {0}).
OutsideInstanceExecutionScope=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Метод {0} может вызываться только во время обработки команды. Не пытайтесь сохранить экземпляр InstancePersistenceContext для дальнейшего использования. Объект InstancePersistenceContext, переданный в команду TryCommand или BeginTryCommand, может использоваться только в ходе обработки этой команды.
OutsideTransactionalCommand=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод {0} для InstancePersistenceContext, которому требуется согласованность транзакций, в рамках выполнения команды, которой не требуется согласованность транзакций. Это может привести к повреждению данных. Эта ошибка указывает на недопустимую реализацию поставщика сохраняемости.
OverloadGroupHasSubsets=Следующие перегруженные группы являются подмножествами группы "{0}": {1}. Одна перегруженная группа не может быть подмножеством другой.
OverloadGroupsAreEquivalent=Следующие перегруженные группы являются эквивалентными: {0}. В данном случае достаточно определить только одну перегруженную группу.
OverloadingMethodMustBeStatic=Метод для перегрузки оператора должен быть статическим.
OverloadOnlyCallableFromWorkflowThread=Перегрузку этого метода можно вызвать только из потока рабочего процесса.
OwnerBelongsToWrongStore=Указан неверный InstanceOwner. Объект InstanceOwner, передаваемый в метод InstanceStore, должен принадлежать InstanceStore. Объект InstanceOwner можно использовать только с создавшим его методом InstanceStore.
OwnerRequired=Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand. Для этой команды требуется владелец экземпляра, однако к дескриптору InstanceHandle не привязан владелец.
ParallelForEachRequiresNonNullValues=Перед использованием действия ParallelForEach "{0}" необходимо привязать значения к непустому выражению.
ParameterNumberMismatch=Параметр "{0}" не существует в операции "{1}" контракта "{2}".
ParameterPositionMismatch=Параметр "{0}" указан в неправильном порядке для операции "{1}" в контракте "{2}". Переместите его в позицию "{3}" в коллекции параметров. 
ParameterTypeMismatch=Тип параметра "{0}" не соответствует типу "{1}", указанному в операции "{2}" реализованного контракта "{3}".
PartialTrustPerformanceCounterNotEnabled=Доступ к счетчикам производительности запрещен. Возможно, приложение запущено с частичным доверием. Либо отключите счетчики производительности, либо настройте приложение за запуск с полным доверием.
PauseWhenPersistableInvalidIfPersistable=Метод PauseWhenPersistable может быть вызван, только когда IsPersistable имеет значение false.
PendingMessagesPerChannelRatio=Отношение ожидающих сообщений на канал: {0}/{1}
PermissionArgumentWrongType=Аргумент имеет неправильный тип. Ожидается "{0}".
PersistenceInitializerThrew=Реализация IPersistenceContextInitializer создала исключение. Не удалось загрузить или создать экземпляр надежной службы, например WorkflowServiceInstance. Свойство InnerException содержит исходное исключение.
PersistencePipelineAbortThrew=Реализация метода Abort в участнике сохраняемости типа "{0}" вызвала исключение. Реализации метода Abort не должны вызывать исключения.
PersistenceProviderRequiredToPersist=Только те экземпляры рабочего процесса, которые были настроены с расширением PersistenceProvider, могут быть сохранены или выгружены.
PersistenceTooLateToEnlist=Прикрепление к транзакции уже невозможно, поскольку началась ее фиксация или прерывание.
PersistenceViolationNoCreate=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Новый экземпляр создан в момент, когда было необходимо вызвать исключение InstanceNotReadyException.
PickBranchRequiresTrigger=Перед использованием действия PickBranch "{0}" необходимо задать триггер.
PickBranchTriggerActionSwapped=Выборка не поддерживает динамическое обновление, если поменять местами триггер и действие в PickBranch.
PrepareForSerializationRequiresPersistability=Метод PrepareForSerialization может быть вызван, только когда IsPersistable имеет значение true.
PrivateMembersHaveChanged=Закрытая реализация этого действия изменена (потомки реализации, делегаты, переменные или аргументы были добавлены, удалены или переупорядочены). Динамическое обновление поддерживает только изменения реализации, указанные в карте реализации, независимо от открытой конфигурации действия.
PromotionAlreadyDefined=Набор продвижений {0} уже определен.
PromotionTooManyDefined=Набор продвижений {0} определяет {1} {2} продвижений, что превышает максимально допустимое число продвижений объекта {3}.
PropertyCannotBeModified=Свойство {0} не может быть изменено после того, как SqlTrackingParticipant начал обрабатывать записи.
PropertyMemberNotSupportedByActivityXamlServices=ActivityXamlServices обнаружен элемент x:Property ({0}), который не поддерживается свойством DynamicActivityProperty.
PropertyMismatch="{0}" не соответствует значению "{1}", равному "{2}", указанному в контракте "{4}" операции "{3}".
PropertyReadOnlyInWorkflowDataContext=Свойство "{0}" доступно только для чтения в контексте WorkflowDataContext.
PropertyReferenceNotFound=Ссылке PropertyReference не удается разрешить свойство"{0}".
ProtectionLevelIsNotSupported=Пользовательские параметры ProtectionLevel поддерживаются только в MessageContract. Укажите тип MessageContract для операции "{0}" реализованного контракта "{1}".
ProtectionLevelNotSupported=Рабочий процесс не поддерживает пользовательские параметры ProtectionLevel при ошибках. Не указывайте ProtectionLevel в FaultContract для операции "{0}" реализованного контракта "{1}".
ProvidedStateInitializedForExecution=Состояние среды выполнения уже инициализировано для выполнения и не может быть обновлено.  Перезагрузите состояние из постоянного хранилища.
ProviderDoesNotSupportCommand=Реализаций InstanceStore в поставщике сохраняемости не поддерживает команду с именем {0}. Выберите другой поставщик или убедитесь, что такая команда сохраняемости не выполняется.
PublicChildrenChangeBlockDU=Это действие не поддерживает изменения в открытых потомках (добавление, удаление или переупорядочивание действий или делегатов действий).
PublicEnvironmentAccessToNonGenericActivity=Доступ к общей среде имеется только для действий, производных от CodeActivity<TResult>, но не от CodeActivity.
PublicMethodWithMatchingParameterDoesNotExist=Действие "{0}" не имеет открытого метода "{1}" с именем "{2}", с совпадающими типами параметров, аргументами универсального типа и ограничениями универсального типа, переданными в метод InvokeMethod "{3}".
PublicReferencesOnActivityRequiringArgumentResolution=Действию "{0}" не удается определить аргументы, кроме встроенного аргумента Result, и объявить доступ к общим местоположениям с помощью CodeActivityPublicEnvironmentAccessor. Передайте все данные действию либо с помощью аргументов, либо с помощью методов CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation и TryGetReferenceToPublicLocation.
QueryActivityIsInImplementation=Это действие находится внутри реализации составного действия "{0}". Для запроса его обновляемости используйте карту реализации для составного действия.
QueryActivityIsNotInDefinition=Это действие не принадлежит ни к исходному, ни к обновленному определению рабочего процесса.
QueryActivityIsPublic=Это действие является частью корневого определения рабочего процесса. Для запроса его обновляемости используйте карту обновления рабочего процесса, а не карту реализации для составного действия "{0}".
QueryCorrelationInitializerCannotBeInitialized=Отсутствует дескриптор корреляции для инициализации QueryCorrelationInitializer. Это является следствием того, что в инициализаторе запросов не задан явный набор дескрипторов и отсутствует дескриптор, доступный для использования из области корреляции.
QueryCorrelationInitializerWithEmptyMessageQuerySet=Действие с DisplayName="{0}" и OperationName="{1}" содержит QueryCorrelationInitializer с пустым MessageQuerySet.
QueryVariableIsInImplementation=Эта переменная находится внутри реализации составного действия "{0}". Для запроса его обновляемости используйте карту реализации для составного действия.
QueryVariableIsNotInDefinition=Эта переменная не принадлежит ни к исходному, ни к обновленному определению рабочего процесса.
QueryVariableIsNotPublic=Эта переменная не является открытой. Только открытые переменные могут быть изменены динамическим обновлением.
QueryVariableIsPublic=Эта переменная является частью корневого определения рабочего процесса. Для запроса его обновляемости используйте карту обновления рабочего процесса, а не карту реализации для составного действия "{0}".
QueuingSqlRetry=Повторная попытка поместить SQL в очередь с задержкой {0} мс.
ReadAccessToWriteOnlyPublicReference=Действию "{0}" не удается выполнить чтение из ссылки на это общее местоположение, так как она была объявлена с помощью ArgumentDirection.Out. Чтобы разрешить чтение и запись, объявите ссылку с помощью ArgumentDirection.InOut.
ReadNotSupported=Чтение не поддерживается для этого потока.
ReadonlyNameScopeCannotBeUpdated=Операцию невозможно использовать, так как реализация области имен доступна только для чтения.
ReadonlyPropertyCannotBeSet=Свойство или индексатор "{0}.{1}" невозможно использовать в этом контексте, так как метод доступа get недоступен.
ReceiveAndReceiveParametersHaveSameName=Две операции Receive с разными типами ReceiveContent имеют одинаковые свойства ServiceContractName и OperationName "{0}".
ReceiveContentChanged=Содержимое этого действия Receive изменилось с бестипового на типовое.
ReceiveCorrelationInitializiersChanged=CorrelationInitializers действия Receive изменилось.
ReceiveIsInTRSWhenTransactionFlowNotAllowed=Действие Receive находится в диапазоне TransactedReceiveScope, в то время как операция "{0}" в реализованном контракте "{1}" имеет параметр TransactionFlowOption со значением NotAllowed.
ReceiveIsNotInTRS=Операция "{0}" в реализованном контракте "{1}" требует обработки транзакции, но действие Receive НЕ находится в диапазоне TransactedReceiveScope.
ReceiveMessageNeedsToPairWithSendMessageForTwoWayContract=Действие Receive настроено на использование операции "запрос-ответ" "{0}", однако при этом отсутствует связанное с ним действие SendReply. Свяжите действие Receive с действием SendReply и скоррелируйте их с помощью дескриптора CorrelationHandle.
ReceiveNotWithinATransactedReceiveScope=Действие Receive, включенное в транзакцию, не входи в область TransactedReceiveScope.
ReceivePairedWithSendReplyAndSendReplyParameters=Операция SendReply с SendMessageContent и операция SendReply с SendParametersContent составляют пары с одинаковыми операциями Receive с OperationName="{0}". Это недопустимо.
ReceiveParametersContentDoesNotSupportMessage=Действие с DisplayName="{0}" содержит аргумент с именем "{1}", который является Message или MessageContract. Метод ReceiveParametersContent не поддерживает Message и MessageContract. Свойство Content должно быть указано как ReceiveMessageContent для Message или MessageContract на основании содержимого.
ReceiveReplyRequestCannotBeNull=Свойство Request в действии "{0}" не может иметь значение NULL. Оно должно быть установлено в действие Send, относящееся к данной паре "запрос-ответ".
ReferencedChildInIsNewlyAdded=Этот метод не может быть вызван для действий, ссылающихся на импортированных потомков. Прежде чем вызывать этот метод, проверьте NativeActivityUpdateContext.IsReferenceToImportedChild.
RegisteredBookmarkScopeRequired=Только зарегистрированные области закладок могут быть использованы для создания закладок с указанием области.
RelativeUriRequiresBinding=У конечной точки с параметрами Name="{0}" и ServiceContract "{1}" есть относительный универсальный код ресурса (URI) "{2}", который невозможно преобразовать в абсолютный URI из-за того, что свойство Binding конечной точки равно null. Задайте свойство Binding или измените относительный универсальный код ресурса (URI) на абсолютный.
RelativeUriRequiresHost=У конечной точки с параметрами Name="{0}" и ServiceContract "{1}" есть относительный универсальный код ресурса (URI) "{2}", который невозможно преобразовать в абсолютный URI из-за того, что аргумент host метода GetAddress равен null. Укажите экземпляр узла службы, в котором будет размещена конечная точка, или измените относительный универсальный код ресурса (URI) на абсолютный.
RemovingTransitionsBlockDU=StateMachine не поддерживает динамическое обновление, если переход удален из текущего состояния.
RenewLockSystemError=Не удалось увеличить срок окончания блокировки, срок окончания блокировки уже истек или владелец блокировки удален. Прерывание блокировки SqlWorkflowInstanceStore.
ReplyShouldNotIncludeRequestReplyHandle=Действие "{0}" с параметром OperationName="{1}" не должно содержать в дополнительных корреляциях дескриптор "запрос-ответ".
RequestMustBeSpecified=В действии "{0}" должен быть указан аргумент Request.
RequestReplyHandleShouldNotBePresentForOneWay=RequestReplyCorrelationInitializer не должен указываться для одностороннего действия Send или Receive. При инициализации корреляции RequestReply действию Send должно быть поставлено в пару действие ReceiveReply, а действию Receive - действие SendReply.
RequiredArgumentValueNotSupplied=Значение обязательного аргумента действия "{0}" не передано.
RequiredExtensionTypeNotFound=Модуль типа "{0}" должен быть настроен для запуска этого потока операций.
RequiredVariableCoundNotBeExtracted=Обязательная переменная {0} недоступна для извлечения в действии: {1}.
RequireExtensionOnlyAcceptsReferenceTypes="{0}" является типом значения. RequireExtension принимает только ссылочные типы.
ResponseContextIsNotNull=Контекст ResponseContext не равен null.
ResultArgumentHasRequiredTypeAndDirection=У предоставленного автором действия объекта RuntimeArgument с именем "Result" должно быть свойство ArgumentDirection со значением Out и типом {0}. Вместо этого у свойства ArgumentDirection значение {1} и тип {2}.
ResultArgumentMustBeBoundToResultProperty=Предоставленный автором действия объект RuntimeArgument с именем "Result" должен быть привязан к аргументу, возвращаемому свойством Result действия.
ResultArgumentMustBeSpecificType=Выходной аргумент Result OutArgument для этого действия должен быть аргументом типа {0}.
ResultCannotBeSetOnArgumentExpressions=Выходной аргумент Result OutArgument в действии<T> не может быть задан, когда действие<T> используется как выражение аргумента.
ResultMustBeSpecified=В действии "{0}" должен быть указан аргумент Result.
RethrowMustBeAPublicChild=Действие Rethrow "{0}" нельзя использовать в закрытом потомке действия TryCatch. Rethrow допускается только в открытых потомках действия TryCatch.
RethrowNotInATryCatch=При повторном создании исключения действие "{0}" должно быть дочерним по отношению к обработчику Catch действия TryCatch.
RetryingSqlCommandDueToSqlError=Выполняется повтор команды SQL из-за ошибки SQL с номером {0}.
ReturnTypeIncompatible=Несовпадение типа. Тип возвращаемого значения "{0}" наиболее подходящего метода "{1}" в типе "{2}" несовместим с аргументом "Result", переданным в метод InvokeMethod "{3}", для которого ожидаются возвращаемые значения типа "{4}".
ReturnValueMissing=Параметр возвращаемого значения типа "{0}" отсутствует для операции "{1}" в контракте "{2}". 
RootActivityAlreadyAssociatedWithInstance=Действие с отображаемым именем "{0}" уже сопоставлено с экземпляром.  Операции с метаданными действия, которое связано с экземпляром, не допускаются.  Эта ошибка также может указывать на попытку выполнения потока операций, в котором корневое действие входит в другой поток операций.
RootActivityCannotBeReferenced=Действие "{0}" является корневым действием, и на него не может ссылаться действие "{1}".
RootArgumentViolationsFound=Значения, предоставленные для аргументов корневого действия, не удовлетворяют требованиям корневого действия:
RootArgumentViolationsFoundNoInputs=Параметры аргумента корневого действия некорректны. Либо исправьте определение рабочего процесса, либо введите допустимые значения, чтобы исправить эти ошибки:
RunnableInstancesDetectionError=Не удалось обнаружить доступные для выполнения экземпляры, поскольку обнаружено следующее исключение
RuntimeArgumentBindingInvalid=Аргумент RuntimeArgument "{0}" ссылается на аргумент, который в свою очередь привязан к аргументу RuntimeArgument с именем "{1}". Убедитесь, что объект Argument привязан не более чем к одному объекту RuntimeArgument и не используется совместно несколькими открытыми свойствами Argument.
RuntimeArgumentChangeBlockDU=Динамическое обновление не может быть разрешено внутри действия "{0}" из-за изменений RuntimeArguments. Чтобы включить динамическое обновление в этом действии, нельзя добавлять, удалять или переупорядочивать аргументы RuntimeArgument. Также нельзя изменять имя, тип и направление.
RuntimeArgumentNotCreated=Экземпляр RuntimeArgument еще не создан.
RuntimeArgumentNotOpen=Невозможно использовать аргумент "{0}".  Убедитесь, что он объявлен в действии.
RuntimeDelegateArgumentDirectionIncorrect=Направление объекта RuntimeDelegateArgument должно совпадать с направлением объекта DelegateArgument, к которому оно привязано.
RuntimeDelegateArgumentTypeIncorrect=Тип объекта RuntimeDelegateArgument должен совпадать с типом объекта DelegateArgument, к которому он привязан.
RuntimeOperationInProgress=Операция среды выполнения уже выполняется.  Доступ к объекту WorkflowInstance должен быть синхронизирован вызывающим объектом.
RuntimeRunning=В данный момент среда выполнения выполняет поток операций, а операции могут выполняться только во время его приостановки.  Доступ к объекту WorkflowInstance должен быть синхронизирован вызывающим объектом.
RuntimeTransactionAlreadyExists=В среде выполнения уже была настроена транзакция.  Разрешено выполнение не более одной транзакции одновременно.
RuntimeTransactionComplete=Транзакция среды выполнения завершена; состояние "{0}".
RuntimeTransactionCompletionRequested=Элемент Activity "{0}", DisplayName: "{1}", InstanceId: "{2}" запланировал завершение транзакции среды выполнения.
RuntimeTransactionHandleNotRegisteredAsExecutionProperty=Метод "{0}" может вызываться, только если соответствующий объект RuntimeTransactionHandle зарегистрирован в качестве свойства выполнения.
RuntimeTransactionIsSuppressed=Данная операция недопустима при подавлении транзакции среды выполнения. Транзакция среды выполнения подавляется, поскольку свойство SuppressTransaction было задано в классе RuntimeTransactionHandle текущей среды.
RuntimeTransactionSet=Транзакция среды выполнения задана элементом Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  Выполнение изолировано в элементе Activity "{3}", DisplayName: "{4}", InstanceId: "{5}".
SameUserStateUsedForMultipleInvokes=Один и тот же экземпляр пользовательского состояния не может использоваться для параллельных вызовов действия.
SavingActivityToXamlNotSupported=Сохранение DynamicActivity и Activity.Implementation в язык XAML не поддерживается.  Если нужно создать параметризованный поток операций и сохранить его в язык XAML, воспользуйтесь классом ActivityBuilder.
SavingFuncToXamlNotSupported=Сохранение общей функции Func<T> в XAML не поддерживается. Чтобы преобразовать объект в сериализуемую функцию, сериализуйте объект в XAML, а затем вызовите метод ActivityXamlServices.CreateFactory.
ScheduleBookmarkWorkItem=Элемент BookmarkWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  BookmarkName: {3}, BookmarkScope: {4}.
ScheduleCancelActivityWorkItem=Элемент CancelActivityWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
ScheduleCompletionWorkItem=Элемент CompletionWorkItem был запланирован для родительского элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  Выполнение элемента Activity "{3}" завершено, DisplayName: "{4}", InstanceId: "{5}".
ScheduleExecuteActivityWorkItem=Элемент ExecuteActivityWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
ScheduleFaultWorkItem=Элемент FaultWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  В элементе Activity "{3}" произошло исключение, DisplayName: "{4}", InstanceId: "{5}".
ScheduleRuntimeWorkItem=Рабочий элемент среды выполнения был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
ScheduleTransactionContextWorkItem=Элемент TransactionContextWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
SchemaContextFromBeforeInitializeComponentXBTExtensionCannotBeGeneric=Имя класса поддержки XAML, созданное расширением сборки задания XAML BeforeInitializeComponent ({0}), не может быть универсальным. Ресурс не может быть создан расширением построения задания XAML BeforeInitializeComponent. Перестройте проект.
SchemaContextFromBeforeInitializeComponentXBTExtensionNotFound=Имя класса поддержки XAML, созданное расширением построения задания XAML BeforeInitializeComponent ({0}), не найдено. Перестройте проект.
SeekNotSupported=Поиск не поддерживается для этого потока.
SendActivityCorrelationHandleNotFound=Не удалось найти допустимый дескриптор связи, связанный с действием отправки с именем "{0}".
SendMessageChannelCacheMiss=Отсутствует SendMessageChannelCache
SendMessageNeedsToPairWithReceiveMessageForTwoWayContract=Действие Send настроено на использование операции "запрос-ответ" "{0}", однако при этом отсутствует связанное с ним действие ReceiveReply. Свяжите действие Send с действием ReceiveReply и скоррелируйте их с помощью дескриптора CorrelationHandle.
SendNotSupported=Метод Send не поддерживается.
SendParametersContentDoesNotSupportMessage=Действие с DisplayName="{0}" содержит аргумент с именем "{1}", который является Message или MessageContract. Метод SendParametersContent не поддерживает Message и MessageContract. Свойство Content должно быть указано как SendMessageContent для Message или MessageContract.
SendReceiveExtensionNotFound=Не удается найти расширение SendReceiveExtension, убедитесь, что приложение, содержащее рабочий процесс, предоставляет реализацию этого расширения.
SendRepliesHaveSameFaultTypeDifferentAction=Два действия SendReply имеют одинаковый тип ошибки, но разные действия.
SendReplyRequestCannotBeNull=Свойство Request в действии "{0}" не может иметь значение NULL. Ему необходимо присвоить действие Receive, принадлежащее данной паре "запрос-ответ".
SendWithUninitializedCorrelatesWith=Действие с именем операции "{0}" содержит неинициализированный дескриптор CorrelatesWith.
SequenceDuplicateReferences=Последовательность не поддерживает динамическое обновление, если она содержит более одной ссылки на один и тот же импортированный потомок.
ServiceEndpointAdded=Конечная точка службы была добавлена для адреса "{0}", привязки "{1}" и контракта "{2}".
ServiceHostExtensionAborted=Операция не может быть выполнена, поскольку узел службы или одно из его расширений были прерваны.
ServiceHostExtensionImmutable=Операция вызывалась при помощи расширения узла службы, которое разрешено использовать только до открытия узла службы.
ServiceInstanceTerminated=Работа экземпляра службы с идентификатором "{0}" завершена.
ServiceInstanceUnloaded=Экземпляр службы с идентификатором "{0}" выгружен из памяти.
ServiceMetadataBehaviorNotFoundForServiceMetadataEndpoint=Не удалось найти контракт с именем "IMetadataExchange" в списке контрактов, реализованных службой {0}.  Чтобы включить поддержку этого контракта, добавьте свойство ServiceMetadataBehavior в файл конфигурации или непосредственно в WorkflowServiceHost.
SetupOrCleanupWorkflowThreadThrew=Интерфейс IExecutionProperty создал исключение при настройке или очистке потока рабочего процесса.  Дополнительные сведения см. в описании внутреннего исключения.
SFxTaskNotStarted=Данный экземпляр задачи еще не запущен. Экземпляры задачи нужно запустить, прежде чем они смогут возвратить результаты каких-либо операций.
ShipAssertExceptionMessage=Произошла непредвиденная ошибка. Приложения не должны обрабатывать эту ошибку. В целях диагностики приводится сообщение на английском языке, связанное с ошибкой: {0}.
SimpleStateMustHaveOneTransition=Состояние "{0}" должно содержать хотя бы одну транзицию.
SpecialMethodNotFound=Особый метод "{0}" типа "{1}" не найден.
SqlExceptionCaught=Обнаружено исключение SQL с номером {0}, сообщение {1}.
StartBookmarkWorkItem=Начинается выполнение элемента BookmarkWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  BookmarkName: {3}, BookmarkScope: {4}.
StartCancelActivityWorkItem=Начинается выполнение элемента CancelActivityWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
StartCompletionWorkItem=Начинается выполнение элемента CompletionWorkItem для родительского элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}". Выполнение элемента Activity "{3}" завершено, DisplayName: "{4}", InstanceId: "{5}".
StartExecuteActivityWorkItem=Начинается выполнение элемента ExecuteActivityWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
StartFaultWorkItem=Начинается выполнение элемента FaultWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  В элементе Activity "{3}" произошло исключение, DisplayName: "{4}", InstanceId: "{5}".
StartRuntimeWorkItem=Начинается выполнение рабочего элемента среды выполнения для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
StartSignpostEvent=Ограничение действия.
StartSqlCommandExecute=Запуск выполнения команды SQL: {0}
StartTransactionContextWorkItem=Начинается выполнение элемента TransactionContextWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".
StateCannotBeAddedTwice=Состояние "{0}" не удалось добавить в конечный автомат дважды.  Все состояния в конечном автомате должны быть уникальными.
StateCannotBeSerialized=Экземпляр "{0}" не может быть запущен или сохранен, поскольку динамическое обновление для него завершилось сбоем. Чтобы запустить экземпляр, перезагрузите свежую копию из хранилища сохраняемости.
StateMachineMustHaveInitialState=У StateMachine "{0}" должно быть начальное состояние.
StateNotBelongToAnyParent=Целевое состояние "{1}" транзиции "{0}" должно принадлежать машине состояний.
StopSignpostEvent=Ограничение действия.
StoreReportedConflictingLockTokens=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она дважды вызвала метод BindInstanceOwner с одним значением instanceOwnerId и разными значениями lockToken. Используйте поставщик сохраняемости, который всегда использует одинаковые значения lockToken для одного владельца экземпляра.
StoreViolationNoInstanceBound=Используемая реализация поставщика сохраняемости InstanceStore недопустима. Реализации не удалось привязать InstanceHandle к экземпляру и установить InstanceState при обработке команды LoadWorkflowByInstanceKeyCommand, LoadWorkflowCommand или TryLoadRunnableWorkflowCommand.
SubexpressionResultWasNotVisible=Результатом части выражения для объекта типа "{0}" является ссылка на расположение, которое не видимо в данной области.
SubexpressionResultWasNull=Результатом части выражения для объекта типа "{0}" является значение NULL.
SwitchCaseKeyTypesMustMatchExpressionType=Варианты переключателя "{0}" содержат {1} ключей, которые несовместимы с типом выражения "{2}".
SwitchCaseNotFound=Действию Switch "{0}" не удалось найти действие Case, соответствующее результату выражения Expression.
SwitchCaseNullWithValueType=Ключ для случая null существует, но Switch Expression является типом значения "{0}". Типы значений не могут принимать значение null.
SwitchCaseTypeMismatch=Ключ варианта "{0}" не принадлежит типу "{1}" и может не соответствовать любому значению, выданному выражением переключателя типа "InArgument<{1}>".
SymbolNamesMustBeUnique=Переменная RuntimeArgument или DelegateArgument с именем "{0}" уже существует. Имена должны быть уникальными в области среды.
SymbolResolverAlreadyExists=Для экземпляра потока операций может быть настроено только одно расширение SymbolResolver.  Расширение SymbolResolver уже существует в WorkflowInstanceExtensionManager.
SymbolResolverDoesNotHaveSymbol=Не удается найти символ "{0}" типа "{1}" в расширении SymbolResolver для данного экземпляра.
SymbolResolverMustBeSingleton=SymbolResolver не может быть использован как модуль для каждого экземпляра. Переопределите singletonObject, чтобы добавить SymbolResolver в WorkflowInstanceExtensionManager.
TargetContractCannotBeOneWayWithTransactionFlow=Недопустимое определение контракта: односторонняя операция имеет параметр TransactionFlowOption со значением Mandatory в операции "{0}" контракта "{1}".
TargetTypeAndTargetObjectAreMutuallyExclusive=Тип TargetType и объект TargetObject являются взаимоисключающими для действия {0} "{1}".
TargetTypeCannotBeEnum=Тип операнда в {0} "{1}" не может быть типом перечисления.
TargetTypeIsValueType=Тип операнда является типом значения. Изменение поля в "{0}" "{1}" ни на что не повлияет.
TaskTimedOutError=Превышено время ожидания задачи после {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.
TextExpressionCompilerActivityNameRequired=TextExpressionCompilerSettings.ActivityName должно быть предоставлено.
TextExpressionCompilerActivityNamespaceRequired=TextExpressionCompilerSettings.ActivityNamespace должно быть предоставлено.
TextExpressionCompilerActivityRequired=TextExpressionCompilerSettings.Activity должно быть предоставлено.
TextExpressionCompilerAddGeneratedFileRequired=TextExpressionCompilerSettings.AddGeneratedFile должен быть предоставлен.
TextExpressionCompilerLanguageRequired=TextExpressionCompilerSettings.Language должен быть предоставлен.
TextExpressionCompilerNoCodebase=Сборка, загруженная для имени "{0}", не содержит значения CodeBase. Значение CodeBase необходимо для компиляции.
TextExpressionCompilerOutputPathRequired=TextExpressionCompilerSettings.OutputPath должен быть предоставлен.
TextExpressionCompilerUnableToLoadAssembly=Не удается загрузить сборку "{0}".
TextExpressionMetadataRequiresCompilation=Для запуска типа действия выражения "{0}" требуется компиляция. Убедитесь, что поток операций скомпилирован.
ThreadNeutralSemaphoreAborted=ThreadNeutralSemaphore был прерван.
ThrowingEtwException=Создание исключения. Источник: {0}. Сведения об исключении: {1}
ThrowingEtwExceptionVerbose=Создание исключения. Источник: {0}. Сведения об исключении: {1}
ThrowingException=Создание исключения. Источник: {0}. Сведения об исключении: {1}
ThrowingExceptionVerbose=Создание исключения. Источник: {0}. Сведения об исключении: {1}
TimedOutWaitingForLockResolution=Поставщику сохраняемости не удалось восстановить блокировку за заданное время ожидания. Это указывает на возможность взаимоблокировки в наборе команд, одновременно выполняемых в различных InstanceHandle, принадлежащих одному InstanceOwner. Чтобы разрешить такую ситуацию, можно использовать несколько владельцев InstanceOwner или сделать так, чтобы свойство InstancePersistenceCommand.AutomaticallyAcquiringLock возвращало значение false для команд, которые не могут получить блокировку для экземпляра.
TimeoutInputQueueDequeue=Время ожидания операции Dequeue истекло после {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.
TimeoutMustBeNonNegative=Аргумент {0} должен быть неотрицательным значением времени ожидания. Было указано значение {1}.
TimeoutMustBePositive=Аргумент {0} должен быть положительным значением времени ожидания. Указанное значение: {1}.
TimeoutOnOperation=Не удалось выполнить операцию за выделенное время ожидания {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.
TimeoutOnSqlOperation=Не удалось выполнить операцию за выделенное время ожидания {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительное время ожидания.
TimeoutOpeningSqlConnection=Истекло время ожидания при открытии соединения SQL. Не удалось выполнить операцию за выделенное время ожидания {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительное время ожидания.
TimerExtensionAlreadyAttached=Данный класс TimerExtension уже был прикреплен к экземпляру рабочего процесса.
TimerExtensionRequiresWorkflowInstance=Класс TimerExtension может использоваться, только если он прикреплен к экземпляру рабочего процесса.
TooManyViolationsForExceptionMessage=<усечено> Сообщение об исключении было усечено из-за большого размера. Используйте класс ActivityValidationServices, чтобы просмотреть все нарушения.
TraceCodeEventLogCritical=Записал в журнал событий.
TraceCodeEventLogError=Записал в журнал событий.
TraceCodeEventLogInfo=Записал в журнал событий.
TraceCodeEventLogVerbose=Записал в журнал событий.
TraceCodeEventLogWarning=Записал в журнал событий.
TraceCorrelationKeys=Вычислен ключ корреляции "{0}" с использованием значений "{1}" родительской области "{2}".
TrackingDataExtracted=Отслеживание данных, извлеченных {0} в действии {1}.
TrackingProfileNotFound=Не найден TrackingProfile "{0}" для ActivityDefinitionId "{1}". Профиль TrackingProfile не найден в файле конфигурации, или обнаружено несоответствие ActivityDefinitionId.
TrackingRecordDropped=Размер записи отслеживания {0} превышает максимально допустимое значение, разрешенное в сеансе трассировки событий Windows для поставщика {1}
TrackingRecordRaised=Запись отслеживания {0} повышена до {1}.
TrackingRecordTruncated=Усеченная запись отслеживания {0} записана в сеанс трассировки событий Windows с использованием поставщика {1}. Данные переменных, заметок, пользователей удалены
TrackingRelatedWorkflowAbort=При вызове участников отслеживания произошла ошибка, которая привела к прерыванию экземпляра.  Дополнительные сведения см. в описании внутреннего исключения.
TrackingValueNotSerializable=Извлеченный аргумент или переменная "{0}" не сериализуется.
TransactedReceiveScopeEndCommitFailed=Вызов EndCommit для CommittableTransaction с id = "{0}" привел к созданию исключения TransactionException со следующим сообщением: "{1}".
TransactedReceiveScopeMustHaveValidReceive=В свойстве Request класса TransactedReceiveScope "{0}" должно быть задано допустимое действие Receive.
TransactedReceiveScopeRequiresReceive=Перед использованием области TransactedReceiveScope "{0}" необходимо задать свойство ReceiveActivity.
TransactionHandleAlreadyHasTransaction=Объект TransactionHandle уже имеет транзакцию. Невозможно настроить новую транзакцию.
TransactionInDoubtNonHost=Включающая транзакция отсутствовала при вызове InstanceStore.Execute или BeginExecute, однако в ходе обработки команды использовалась внутренняя транзакция. Внутренняя транзакция переведена в состояние InDoubt.
TransactionPersistenceTimeout=Истекло время ожидания запроса, поскольку экземпляр заблокирован другими транзакциями.
TransactionRolledBackNonHost=Включающая транзакция отсутствовала при вызове InstanceStore.Execute или BeginExecute, однако в ходе обработки команды использовалась внутренняя транзакция. Внутренняя транзакция прервана.
TransitionCannotBeAddedTwice=Переход "{0}" нельзя добавить в состояние "{1}", так как он был добавлен в состояние "{2}".
TransitionTargetCannotBeNull=Свойство "To" транзиции "{0}" состояния "{1}" не должно быть равно нулю.
TriggerOrConditionChangedDuringTransitioning=StateMachine не поддерживает динамическое обновление, если действие Trigger или Condition выполняющегося перехода было изменено.
TriggerOrConditionIsReferenced=StateMachine не поддерживает динамическое обновление, если любое из действий Trigger или Condition является ссылкой на импортированного потомка.
TryCatchExceptionDuringCancelation=При отмене дочернего действия для действия TryCatch "{0}" произошло исключение.
TryCatchExceptionFromCatchOrFinally=В действии Catch или Finally, связанном с действием TryCatch "{0}", произошло исключение.
TryCatchExceptionFromTry=В действии TryCatch "{0}" было перехвачено исключение типа "{1}".
TryCatchInvalidStateForUpdate=Не удается выполнить обновление внутри TryCatch, так как исключение типа "{0}" было выявлено, но соответствующий блок catch был удален.
TryCommandCannotExecuteSubCommandsAndReduce=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вернула значение false из команды TryCommand (или EndTryCommand) после выполнения вложенной команды с помощью InstancePersistenceContext.Execute (или BeginExecute). Если поставщик сохраняемости распознает команду и обрабатывает ее, он должен возвращать значение true.
TryLoadRequiresOwner=Для операции WorkflowApplication.LoadRunnableInstance требуется явно созданный InstanceOwner. Чтобы использовать этот метод, создайте владельца экземпляра, имеющего тип узла рабочих процессов, и задайте его в свойстве DefaultInstanceOwner объекта InstanceStore.
TryLoadRequiresWorkflowType=Чтобы найти и загрузить доступный для выполнения экземпляр в хранилище, в запрашивающем объекте InstanceOwner во время создания нужно указать тип узла рабочих процессов. Для этого добавьте пару "ключ-значение" в контейнер свойств CreateWorkflowOwnerCommand.InstanceOwnerMetadata во время выполнения команды. Ключом является WorkflowHostType, описанный в документации. Значение должно иметь тип XName и совпадать со значением для загружаемого экземпляра.
TryRegisterRequestContextFailed=Часть контекста обработчика корреляций была неверно использована. Убедитесь, что обработчик был правильно инициализирован средой выполнения и в рабочем процессе за операцией Send следуют операции Receive или ReceiveReply.
TwoReceiveParametersWithSameNameButDifferentParameterCount=Два объекта ReceiveParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разное число параметров.
TwoReceiveParametersWithSameNameButDifferentParameterName=Два объекта ReceiveParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные имена параметров.
TwoReceiveParametersWithSameNameButDifferentParameterType=Два объекта ReceiveParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы параметров.
TwoReceivesWithSameNameButDifferentAction=Два объекта Receive с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные действия.
TwoReceivesWithSameNameButDifferentIsOneWay=Два объекта Receive с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные значения IsOneWay.
TwoReceivesWithSameNameButDifferentTxProperties=Два объекта Receive с одинаковыми именами ServiceContractName и OperationName "{0}" имеют различные свойства транзакции.
TwoReceivesWithSameNameButDifferentValueType=Два объекта Receive с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы ValueType.
TwoSendRepliesWithSameNameButDifferentAction=Два объекта SendReply с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные действия.
TwoSendRepliesWithSameNameButDifferentValueType=Два объекта SendReply с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы ValueType.
TwoSendReplyParametersWithSameNameButDifferentParameterCount=Два объекта SendParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разное число параметров.
TwoSendReplyParametersWithSameNameButDifferentParameterName=Два объекта SendParameters с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные имена параметров.
TwoSendReplyParametersWithSameNameButDifferentParameterType=Два объекта SendParameters с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы параметров.
TwoWayIsImplementedAsOneWay=Операция "{0}" в контракте "{1}" указана как двунаправленная, но отсутствует действие SendReply. Добавьте действие SendReply для этой операции.
TypeConverterHelperCacheAddFailed=Не удалось добавить метод TypeConverterHelper для типа "{0}" во внутренний кэш вспомогательных методов.
TypeMismatchForAssign=Невозможно присвоить типу "{0}" тип "{1}" в действии Assign "{2}".
TypeMustbeValueType=Тип "{0}" должен быть типом значения.
TypeNotAssignableTo={1} нельзя присвоить значение {0}.
UnableToDeserializeHttpResponseContent=Не удалось выполнить десериализацию ResponseContent типа "{0}".
UnableToLocateCompiledLocationContext=Невозможно обнаружить ICompiledExpressionRoot для скомпилированного местоположения "{0}". Убедитесь, что определение действия, содержащего это выражение, скомпилировано.
UnableToOpenAndRegisterStore=Не удалось инициализировать объект InstanceStore.
UnconditionalTransitionShouldNotShareNullTriggersWithOthers=Переход без триггера "{0}" для состояния "{1}" должен иметь условие.  Состояние может иметь только один безусловный переход, не имеющий триггера.
UnconditionalTransitionShouldNotShareTriggersWithOthers=Переход "{0}" состояния "{1}" является безусловным. Он не должен иметь тот же триггер "{2}", что и другие переходы.
UnexpectedArgumentCount=Число аргументов, заданных в коллекции "{0}", равно "{1}", а ожидалось "{2}". 
UnexpectedExpressionNodeType=Ожидался узел выражения типа "{0}", но был указан узел выражения типа "{1}".
UnhandledException=Необработанное исключение. Сведения об исключении: {0}
UninitializedCannotHaveData=Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке экземпляра в состоянии InstanceState.Uninitialized, который содержит данные экземпляра. Неинициализированные экземпляры не могут содержать данные.
UnInitializedRuntimeTransactionHandle=Указанный объект RuntimeTransactionHandle не был инициализирован должным образом.
UnknownCompressionOption=Запрошенный параметр сжатия {0} не является допустимым.
UnknownDatabaseVersion=Версия базы данных не может быть определена, так как в таблице System.Activities.DurableInstancing.SqlWorkflowInstanceStoreVersionTable не найдено строк. Эта таблица должна содержать одну строку, соответствующую версии платформы, в которой она была создана или до которой была обновлена.
UnknownExpressionCompilationError=При обработке выражения "{0}" произошла неизвестная ошибка. При обработке текста выражения исключений не возникло, но также не создано и выполняемое выражение.
UnknownLanguage=Не удается использовать "{0}" как язык для выражений.
UnknownSprocResult=Хранимая процедура возвратила неизвестный результат выполнения {0}.
UnlockInstanceException=При попытке разблокировать экземпляр обнаружено исключение {0}.
UnmatchedNoPersistExit=В объекте NoPersistHandle обнаружен несогласованный выход.  Для каждого входа может быть вызван только один выход.
UnopenedActivitiesCannotBeExecuted=Можно выполнять только открытые действия.  Действие "{0}" не открыто.
UnsupportedExpressionType=Выражение типа "{0}" не поддерживается.
UnsupportedLocationReferenceValue=Значение LocationReference должно быть переменной, RuntimeArgument или DelegateArgument.
UnsupportedMemberExpressionWithType=Выражение MemberExpression, получающее член типа "{0}", не поддерживается.
UnsupportedReferenceExpressionType=Выражение типа "{0}" для значения LValue не поддерживается.
UnusedInputArguments=Следующие ключи из словаря вводимых значений не соответствуют аргументам и должны быть удалены: {0}. Обратите внимание, что имена аргументов задаются с учетом регистра.
UnwrappedMessageNotSupported=Неупакованные сообщения поддерживаются только с помощью MessageContract. Используйте тип MessageContract для операции "{0}" реализованного контракта "{1}".
UpdateDefinitionNotFound=WorkflowIdentity "{0}" не соответствует любой из размещенных служб WorkflowService.
UpdateMapBuilderRequiredProperty=Необходимо задать свойство "{0}" для DynamicUpdateMapBuilder.
UpdateMapNotFound=DynamicUpdateMap доступные для обновления из WorkflowIdentity "{0}" в "{1}" отсутствуют.
UpdateSymbolsMustMatch=Исходный и обновленный рабочий процесс должны иметь одинаковый номер, имя, тип и порядок внешних символов.
UriBaseMustBeSpecified=В действии "{0}" должен быть указан аргумент UriBase.
UseInstanceStoreInsteadOfPersistenceProvider=Класс System.ServiceModel.Activities.WorkflowServiceHost не совместим с System.ServiceModel.Persistence.PersistenceProviderBehavior.  Следует удалить PersistenceProviderBehavior или производный класс, такой как SqlPersistenceProviderBehavior.  Для поддержки сохраняемости с WorkflowServiceHost следует использовать режим, который устанавливает System.Runtime.DurableInstancing.InstanceStore, например SqlInstanceStoreBehavior.
ValidateUnlockInstance=Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand. Для команды необходимо, чтобы свойство UnlockInstance имело значение true, если свойство CompleteInstance имеет значение true.
ValidationContextCannotBeNull=Аргумент ToValidateContext объекта {0} с именем "{1}" был разрешен в значение null.  Необходимо предоставить объект контекста проверки, не равный null.
ValidationErrorPrefixForHiddenActivity=В закрытой реализации действия "{0}" обнаружена следующая ошибка проверки:   
ValidationErrorPrefixForPublicActivityWithHiddenParent=В закрытой реализации действия "{0}" обнаружена следующая ошибка проверки в действии "{1}":   
ValueArgumentTypeNotDerivedFromValueType=Тип ArgumentType сообщения не является производным от типа DeclaredMessageType в действии "{0}" с параметром OperationName="{1}".
ValueCannotBeNegative=Значение "{0}" должно быть больше либо равно нулю.
ValueCannotBeNull=Свойство Content должно быть задано в действии "{0}" с параметром OperationName="{1}".
ValueCollectionUpdatesNotAllowed=Изменение коллекции значений, полученных из словаря, запрещено.
ValueMustBeAssignableToType=Предоставленное значение должно быть таким, чтобы его можно было присвоить предоставленному типу.
ValueMustBeNonNegative=Значение должно быть неотрицательным.
ValueTooLarge="{0}" больше значения Int32.MaxValue не одобрено. Для отключения таймаута укажите значение TimeSpan.MaxValue.
VariableAlreadyInUseOnActivity=Переменную "{0}" нельзя использовать в действии "{1}", поскольку она уже используется в действии "{2}".
VariableCannotBePopulatedInLocationEnvironment=Переменную {0} нельзя заполнять в среде LocationEnvironment.
VariableDoesNotExist=Переменная "{0}" в этой среде не существует.
VariableExpressionTypeMismatch=Значение по умолчанию для переменной "{0}" должно относиться к типу "{1}", однако предоставлено действие с типом результата "{2}".
VariableIsReadOnly=Переменная "{0}" предназначена только для чтения и не может быть изменена.
VariableMustBeSet=Перед вызовом метода CacheMetadata необходимо задать значение переменной.
VariableNameNotAnIdentifier=Невозможно выполнить сериализацию имени переменной "{0}", поскольку оно не является допустимым идентификатором.
VariableNotOpen=Не удается использовать переменную "{0}" типа "{1}". Убедитесь, что эта переменная объявлена в действии или объекте SymbolResolver.
VariableNotVisible=Объект Variable (имя = "{0}"), на который делается ссылка, невидим в данной области. Может существовать другая ссылка на расположение с таким же именем, которое видимо в данной области, но она ссылается на другое расположение.
VariableOnlyAccessibleAtScopeOfDeclaration=Действие "{0}" не имеет доступа к этой переменной, поскольку она объявлена в области действия "{1}".  Действие имеет доступ только к собственным переменным реализации.
VariableOrArgumentAdditionToReferencedEnvironmentNoDUSupported=Добавление переменных или аргументов в уже завершенное действие, на которое может ссылаться обработчик компенсации или обработчик подтверждения, не поддерживается.
VariableOrArgumentDoesNotExist=Переменная или аргумент "{0}" в этой среде не существует.
VariableShouldBeOpen=Перед использованием переменной "{0}" она должна быть включена в действие.
VariableTypeInvalid=Переменную "{0}" нельзя использовать в выражении типа "{1}", поскольку она относится к несовместимому типу "{2}".
VariableTypeNotMatchLocationType=Тип переменной "{0}" не соответствует типу расположения "{1}".
VBExpressionTamperedSinceLastCompiled=Сбой при получении дерева выражений с помощью метода GetExpressionTree, поскольку произошло изменение видимых ему текста выражения VisualBasic или среды LocationReferenceEnvironment со времени их кэширования.  Сообщение об ошибке компиляции: {0}.
WaitAlreadyInProgress=Объект InstanceHandle может иметь не более одной незавершенной операции WaitForEvents или BeginWaitForEvents в каждый момент времени. Запрошена вторая операция. Операцию WaitForEvents ил BeginWaitForEvents следует вызывать только после завершения предыдущей операции.
WaitForEventsTimedOut=Время ожидания операции WaitForEvents или BeginWaitForEvents истекло через {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительный интервал ожидания.
WDCDisposed=Объект WorkflowDataContext доступен только из области действия, в которой он был получен.
WfMessageReceived=Сообщение, полученное рабочим процессом
WfMessageSent=Сообщение, отправленное из рабочего процесса
WhileRequiresCondition=Перед использованием действия While "{0}" необходимо задать условие.
WindowsGroupNotFound=Не удается найти группу окон "{0}".
WorkflowAbortedReason=Сообщение InnerException {0}: {1}
WorkflowActivityResume=Элемент WorkflowInstance с идентификатором "{0}", действие E2E
WorkflowActivityStart=Элемент WorkflowInstance с идентификатором "{0}", действие E2E
WorkflowActivityStop=Элемент WorkflowInstance с идентификатором "{0}", действие E2E
WorkflowActivitySuspend=Элемент WorkflowInstance с идентификатором "{0}", действие E2E
WorkflowApplicationAborted=Операция не может быть выполнена, поскольку работа приложения WorkflowApplication {0} прервалась.
WorkflowApplicationAlreadyHasId=Для WorkflowApplication сформирован идентификатор экземпляра, поскольку было считано свойство "Id". После формирования идентификатора WorkflowApplication не может быть использован для загрузки экземпляра.
WorkflowApplicationCompleted=Элемент WorkflowInstance с идентификатором "{0}" завершил работу в состоянии Closed.
WorkflowApplicationIdled=Идентификатор класса WorkflowApplication: "{0}" перешел в состояние простоя.
WorkflowApplicationInstanceAbandoned=Этот экземпляр WorkflowApplicationInstance уже был отменен или находится в процессе отмены. С ним невозможны никакие дальнейшие операции.
WorkflowApplicationInstanceLoaded=Этот экземпляр WorkflowApplicationInstance уже был связан с приложением WorkflowApplication. Для управления экземпляром используйте это приложение WorkflowApplication.
WorkflowApplicationPersistableIdle=Приложение с идентификатором WorkflowApplication: "{0}" бездействует и является сохраняемым.  Будет выполняться следующее действие: {1}.
WorkflowApplicationPersisted=Идентификатор класса WorkflowApplication: "{0}" был сохранен.
WorkflowApplicationTerminated=Идентификатор класса WorkflowApplication: "{0}" был завершен. Был прерван в состоянии сбоя с исключением.
WorkflowApplicationUnhandledException=Идентификатор класса WorkflowInstance: в "{0}" обнаружено необработанное исключение. Исключение произошло в действии "{1}" (отображаемое имя "'{2}"). Будет предпринято следующее действие: {3}.
WorkflowApplicationUnloaded=Элемент WorkflowInstance с идентификатором "{0}" выгружен из памяти.
WorkflowBehaviorWithNonWorkflowHost=Поведение "{0}" должно быть применено к WorkflowServiceHost.
WorkflowCompletionAsyncResultCannotBeNull=Значение AsyncResult, возвращенное объектом OnBeginWorkflowCompleted, не может быть null.
WorkflowControlEndpointDefaultBaseUriNotSupportedInPartialTrust=Значение по умолчанию для WorkflowControlEndpoint.DefaultBaseUri не поддерживается в режиме частичного уровня доверия. Используйте конфигурацию или конструктор, не используемый по умолчанию, для указания привязки и адреса для WorkflowControlEndpoint.
WorkflowIdentityNullHostId=Экземпляр, сохраняемый с идентификатором WorkflowIdentity ("{0}"), не может быть загружен на узел без указания идентификатора WorkflowIdentity.
WorkflowIdentityNullStateId=Экземпляр, сохраняемый без идентификатора WorkflowIdentity, не может быть загружен на узел, для которого был указан идентификатор WorkflowIdentity ("{0}"). Экземпляр можно загрузить с помощью другого определения или обновить с помощью динамического обновления.
WorkflowIdentityStateIdHostIdMismatch=Параметр WorkflowIdentity ("{0}") загруженного экземпляра действия не соответствует параметру WorkflowIdentity ("{1}") указанного определения рабочего процесса. Экземпляр можно загрузить с помощью другого определения или обновить с помощью динамического обновления.
WorkflowInstanceAborted=Не удалось выполнить операцию, поскольку прервано выполнение WorkflowInstance "{0}".
WorkflowInstanceAbortedRecordWithId=TrackRecord = WorkflowInstanceAbortedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}
WorkflowInstanceCanceled=Элемент WorkflowInstance с идентификатором "{0}" завершил работу в состоянии Canceled.
WorkflowInstanceCompleted=Не удалось выполнить операцию, поскольку завершено выполнение WorkflowInstance "{0}".
WorkflowInstanceIsReadOnly=WorkflowInstance "{0}" нельзя изменять после запуска.
WorkflowInstanceNotFoundInStore=Экземпляр "{0}" обнаружен в хранилище экземпляров, однако он не содержит поток операций.
WorkflowInstanceRecordWithId=TrackRecord= WorkflowInstanceRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}
WorkflowInstanceSuspendedRecord=TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, причина = {4}, заметки = {5}, ProfileName = {6}
WorkflowInstanceSuspendedRecordWithId=TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}
WorkflowInstanceTerminated=Не удалось выполнить операцию, поскольку выполнение WorkflowInstance "{0}" завершено.
WorkflowInstanceTerminatedRecord=TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}
WorkflowInstanceTerminatedRecordWithId=TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}
WorkflowInstanceUnhandledExceptionRecordWithId=TrackRecord = WorkflowInstanceUnhandledExceptionRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, SourceName = {4}, SourceId = {5}, SourceInstanceId = {6}, SourceTypeName={7}, Exception ={8}, Annotations = {9}, ProfileName = {10}, WorkflowDefinitionIdentity = {11}
WorkflowInstanceUnloaded=Не удалось выполнить операцию, поскольку экземпляр WorkflowInstance "{0}" выгружен.
WorkflowInstanceUnlocked=Невозможно выполнить операцию, поскольку экземпляр WorkflowInstance {0} разблокирован.
WorkflowInstanceUpdatedRecord=TrackRecord= WorkflowInstanceUpdatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, OriginalDefinitionIdentity = {5}, UpdatedDefinitionIdentity = {6}, Annotations = {7}, ProfileName = {8}
WorkflowInstanceUpdateFailed=Не удалось обновить WorkflowInstance "{0}" до идентификатора "{1}". Проверьте выходные данные отслеживания на наличие списка выполняющихся действий, которые не удалось обновить.
WorkflowMustBeHosted=Убедитесь, что действие Receive размещено в узле WorkflowServiceHost.
WorkflowServiceDefinitionIdentityNotMatched=Параметр WorkflowIdentity ("{0}") загруженного экземпляра действия не соответствует ни одной из размещенных служб WorkflowService.
WorkflowServiceHostCannotAddOrRemoveServiceDefinitionAfterOpen=Определения WorkflowService нельзя добавлять или удалять после открытия, сбоя, отмены или закрытия WorkflowServiceHost.
WorkflowTerminatedExceptionDefaultMessage=Рабочий процесс был завершен действием Terminate.
WorkItemAbortedInstance=Обработка ошибки текущего рабочего элемента вызвала прерывание потока операций.  Подробные сведения см. в описании внутреннего исключения.
WrapperNotSupportedInMessageContract=Пользовательские имена и пространства имен оболочек поддерживаются только с помощью контрактов MessageContract. Используйте тип MessageContract для операции "{0}" реализованного контракта "{1}".
WriteAccessToReadOnlyPublicReference=Действию "{0}" не удается выполнить запись в это общее местоположение по ссылке, так как она была объявлена с помощью ArgumentDirection.In. Чтобы разрешить чтение и запись, объявите ссылку с помощью ArgumentDirection.InOut.
WriteonlyPropertyCannotBeRead=Свойство индексатора "{0}.{1}" нельзя использовать в этом контексте, поскольку метод доступа get недоступен.
WrongArgumentType=Аргумент имеет неправильный тип.  Он относится к типу "{0}", а должен относиться к типу "{1}".
WrongCacheMetadataForCodeActivity=Метод CacheMetadata, который принимает параметр ActivityMetadata, не должен вызываться в классах CodeActivity или AsyncCodeActivity. Правильный метод CacheMetadata для этих классов принимает параметр CodeActivityMetadata.
WrongCacheMetadataForNativeActivity=Метод CacheMetadata, который принимает параметр ActivityMetadata, не должен вызываться в классе NativeActivity. Правильный метод CacheMetadata для класса NativeActivity принимает параметр NativeActivityMetadata.
WrongEnvironmentCount=Ожидалось, что действие "{0}" будет иметь аргументов: "{1}", открытых переменных: "{2}", закрытых переменных: "{3}" и делегатов аргументов времени выполнения: "{4}". В действительности имеется аргументов: "{5}", открытых переменных: "{6}", закрытых переменных: "{7}", делегатов аргументов времени выполнения: "{8}".
WrongMemberCount=IdSpace с владельцем "{0}" имеет {1} членов. Ожидалось "{2}".
WrongNumberOfArgumentsForActivityDelegate=Аргументы ActivityDelegate не соответствуют объявленным. Проверьте конфигурацию действия и убедитесь, что оно синхронизировано с объявленным делегатом ActivityDelegate.
WrongOnCreateDynamicUpdateMapForNativeActivity=Метод OnCreateDynamicUpdateMap, принимающий параметр UpdateMapMetadata, не должен вызываться для NativeActivity. Правильный метод OnCreateDynamicUpdateMap для NativeActivity принимает параметр NativeActivityUpdateMapMetadata.
WrongOriginalEnvironmentCount=Ожидалось, что исходное окружение действия "{0}" будет иметь аргументов: "{1}", открытых переменных: "{2}", закрытых переменных: "{3}" и делегатов аргументов времени выполнения: "{4}"; всего: "{5}". Общее число местоположений: "{6}".
XamlBuildTaskResourceNotFound=Предполагалось, что ресурс XAML будет создан расширением построения задания XAML ({0}). Этот ресурс не найден. Перестройте проект.
XamlElementExpected=Ожидается представление элемента.
XamlElementExpectedAt=В строке ({0}, {1}) ожидается представление элемента.
